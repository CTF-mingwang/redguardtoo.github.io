
<p>Before creating wxDataViewListCtrl, it's better to detect information about text size so that we can set the column width and height intelligently.
</p>
<p>
Here is the code:
</p>



<pre class="prettyprint lang-c">
void GuessRowSize(int* w, int* h) {
    //@see http://sourceforge.net/apps/trac/codelite/browser/trunk/LiteEditor/new_build_tab.cpp?rev=5804

// Determine the row height
    wxBitmap tmpBmp(1, 1);
    wxMemoryDC memDc;
    memDc.SelectObject(tmpBmp);
    wxFont f = wxSystemSettings::GetFont(wxSYS_ANSI_FIXED_FONT);
    int xx, yy;
    memDc.GetTextExtent(wxT("Tp"), &amp;xx, &amp;yy, NULL, NULL, &amp;f);

    //enough height for ICON
    *h=yy&lt;16? 16: yy;

    memDc.GetTextExtent("Wp", &amp;xx, &amp;yy, NULL, NULL, &amp;f);
    *w=xx/2;

    return;
}
wxDataViewListCtrl* ctrl=new wxDataViewListCtrl(parent,-1);
ctrl-&gt;Create(parent,id,wxDefaultPosition,wxDefaultSize);
int w,h;
GuessRowSize(&amp;w,&amp;h);
//hard code width may not be good, may be can use w ,h
AppendTextColumn(_T("Column 1"),wxDATAVIEW_CELL_INERT,200 /*width*/);
//must be called after Create()
ctrl-&gt;SetRowHeight(h+6);


// well I need provide button render by myself
class wxDataViewMyButtonRenderer: public wxDataViewCustomRenderer, public wxTimer
{
public:
    wxDataViewMyButtonRenderer( const wxString &amp;varianttype = wxT("wxString"),
                              int align = wxDVR_DEFAULT_ALIGNMENT );

    virtual bool SetValue( const wxVariant &amp;value );
    virtual bool GetValue( wxVariant &amp;value ) const;

    virtual bool Render( wxRect, wxDC*, int);
    virtual wxSize GetSize() const;
    virtual void Notify();
    void SetParent(GalleryListView*);
    // Implementation only, don't use nor override
    virtual bool ActivateCell(const wxRect&amp; rect,
        wxDataViewModel *model,
        const wxDataViewItem&amp; item,
        unsigned int col,
        const wxMouseEvent *mouseEvent);

private:
    wxString m_value;
    bool m_button_clicked;
    wxRect m_cell_rect;
    GalleryListView* m_parent;

protected:
    DECLARE_DYNAMIC_CLASS_NO_COPY(wxDataViewMyButtonRenderer)
};
</pre>



<p>
When user click one row, the ActivateCell is called, we can use some rect detect algorithm to find if the button rect is clicked.
</p>
<p>
There is no mouse up event handler! So I have to hack, basically start a wxTimer when button clicked and draw the button up effect after about 1 second in Notify(). That's why I ask wxDataViewMyButtonRenderer to inherit from wxTimer.
</p>
<p>
To draw the button up effect, I need ask the parent wxDataViewListCtrl to refresh itself, so that the button's Render() method has a chance to be called. That's why we need SetParent().
</p>
<p>
Here is the part of implementation:
</p>



<pre class="prettyprint lang-c">
bool
wxDataViewMyButtonRenderer::ActivateCell(const wxRect&amp; rect,
    wxDataViewModel *model,
    const wxDataViewItem&amp; item,
    unsigned int col,
    const wxMouseEvent *mouseEvent)
{
    wxDataViewListStore* store=(wxDataViewListStore*) model;

    if ( mouseEvent ) {
        if ( !wxRect(GetSize()).Contains(mouseEvent-&gt;GetPosition()) ){
            return false;
        }
        wxVariant item_value_pdf;
        store-&gt;GetValueByRow(item_value_pdf , store-&gt;GetRow(item),0);
        wxVariant item_value_created;
        store-&gt;GetValueByRow(item_value_created , store-&gt;GetRow(item),1);

        m_button_clicked=true;
        m_cell_rect=rect;
    } else {
        wxLogDebug(_T("Sorry, I don't handle keyboard"));
    }

    return true;
}

bool
wxDataViewMyButtonRenderer::Render( wxRect rect, wxDC *dc, int state )
{
    wxLogDebug(_T("Render called"));
    // Ensure that the check boxes always have at least the minimal required
    // size, otherwise DrawCheckBox() doesn't really work well. If this size is
    // greater than the rect size, the checkbox will be truncated but this is a
    // lesser evil.
    wxSize size = rect.GetSize();
    size.IncTo(GetSize());
    rect.SetSize(size);

    // draw button
    if(m_button_clicked==true &amp;&amp; rect.Intersects(m_cell_rect)){
        //draw the button when clicked
        dc-&gt;SetBrush(wxBrush(wxColour(65, 150, 65), wxBRUSHSTYLE_SOLID));
        dc-&gt;SetPen( *wxBLACK_PEN );
        dc-&gt;DrawRectangle(rect);

        // draw button push down effect. since we cannot detect mouse up event, we use
        // timer to draw it
        const int time_to_button_up=350;
        StartOnce(time_to_button_up);
    } else {
        // draw normal button
        dc-&gt;SetBrush(wxBrush(wxColour(84, 174, 84), wxBRUSHSTYLE_SOLID));
        dc-&gt;SetPen( *wxBLACK_PEN );
        dc-&gt;DrawRectangle(rect);

        //draw inner white border
        rect.Deflate(1);
        dc-&gt;SetPen( *wxWHITE_PEN );
        dc-&gt;DrawRectangle(rect);
    }

    dc-&gt;SetTextForeground(*wxWHITE);
    dc-&gt;DrawLabel(m_value,wxRect(dc-&gt;GetTextExtent(m_value)).CentreIn(rect));

    return true;
}
</pre>


