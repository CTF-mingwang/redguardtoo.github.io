
<p>It's not good practice to use relative path in big project.
</p>
<p>
Reasons:
</p><ul>
<li>If file B refer to file A with "../A". Then B's position in the project *CANNOT be changed. Or else its reference to A will be wrong.
</li>
<li>Relative path is not intuitive when debugging.
</li>
<li>If the dependency is complex. Figure out the right path is mission impossible. For example, file A refer to file B with "./a/../../B" and file B refer to file C  "../../b/C".
</li>
</ul>


<p>
So you should <b>ALWAYS use the absolute path</b>.
</p>
<p>
Absolute path is tedious to type and not portable.
</p>
<p>
It could be improved a little bit be use an environment variable to replace the common prefix of the full path.
</p>
<p>
For example, we can replace absolute path "/home/cb/projects/app1/src/test.c" with "$TTAGROOT/src/test.c", if the value of environment variable TTAGROOT is "/home/cb/projects/app1".
</p>
<p>
Insert below code into ~/.bashrc so TTAGROOT value is set when you logged into bash:
</p>



<pre class="prettyprint lang-sh">
export TTAGROOT="/home/cb/projects/app1"
</pre>



<p>
In you script to do the real job, you could make TTAGROOT optional and still use your full path happily. It's just one bash liner.
</p>
<p>
Here is a sample file named test.sh:
</p>



<pre class="prettyprint lang-sh">
#!/bin/bash
[ -z "$TTAGROOT" ] &amp;&amp; TTAGROOT="hard-coded-full-path"
echo "TTAGROOT = $TTAGROOT"
</pre>



<p>
You could use test.sh without $TTAGROOT. Or you can set up default value of $TTAGROOT in ~/.bashrc as I already mentioned.
</p>
<p>
Or you can override the TTAGROOT value when you executing "test.sh":
</p>



<pre class="prettyprint lang-sh">
TTAGROOT="hello" ./test.sh
</pre>



<p>
BTW, don't abuse this technique. Set <b>one environment variable</b> for the root directory of project is enough.
</p>