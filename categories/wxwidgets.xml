<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/"><channel><title>Chen's blog (Posts about wxwidgets)</title><link>http://blog.binchen.org/</link><description></description><atom:link href="http://blog.binchen.org/categories/wxwidgets.xml" type="application/rss+xml" rel="self"></atom:link><language>en</language><lastBuildDate>Sun, 12 Nov 2017 09:40:33 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>How to embed button in wxDataViewListCtrl</title><link>http://blog.binchen.org/posts/how-to-embed-button-in-wxdataviewlistctrl.html</link><dc:creator>Chen Bin</dc:creator><description>&lt;div&gt;&lt;p&gt;
to embed button in wxDataViewListCtrl                                     :en:c::wxwidgets:
&lt;/p&gt;

&lt;p&gt;
Before creating wxDataViewListCtrl, it's better to detect information about text size so that we can set the column width and height intelligently.
&lt;/p&gt;

&lt;p&gt;
Here is the code:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre&gt;&lt;code class="lang-c"&gt;void GuessRowSize(int* w, int* h) {
    //@see http://sourceforge.net/apps/trac/codelite/browser/trunk/LiteEditor/new_build_tab.cpp?rev=5804

// Determine the row height
    wxBitmap tmpBmp(1, 1);
    wxMemoryDC memDc;
    memDc.SelectObject(tmpBmp);
    wxFont f = wxSystemSettings::GetFont(wxSYS_ANSI_FIXED_FONT);
    int xx, yy;
    memDc.GetTextExtent(wxT("Tp"), &amp;amp;xx, &amp;amp;yy, NULL, NULL, &amp;amp;f);

    //enough height for ICON
    *h=yy&amp;lt;16? 16: yy;

    memDc.GetTextExtent("Wp", &amp;amp;xx, &amp;amp;yy, NULL, NULL, &amp;amp;f);
    *w=xx/2;

    return;
}
wxDataViewListCtrl* ctrl=new wxDataViewListCtrl(parent,-1);
ctrl-&amp;gt;Create(parent,id,wxDefaultPosition,wxDefaultSize);
int w,h;
GuessRowSize(&amp;amp;w,&amp;amp;h);
//hard code width may not be good, may be can use w ,h
AppendTextColumn(_T("Column 1"),wxDATAVIEW_CELL_INERT,200 /*width*/);
//must be called after Create()
ctrl-&amp;gt;SetRowHeight(h+6);


// well I need provide button render by myself
class wxDataViewMyButtonRenderer: public wxDataViewCustomRenderer, public wxTimer
{
public:
    wxDataViewMyButtonRenderer( const wxString &amp;amp;varianttype = wxT("wxString"),
                              int align = wxDVR_DEFAULT_ALIGNMENT );

    virtual bool SetValue( const wxVariant &amp;amp;value );
    virtual bool GetValue( wxVariant &amp;amp;value ) const;

    virtual bool Render( wxRect, wxDC*, int);
    virtual wxSize GetSize() const;
    virtual void Notify();
    void SetParent(GalleryListView*);
    // Implementation only, don't use nor override
    virtual bool ActivateCell(const wxRect&amp;amp; rect,
        wxDataViewModel *model,
        const wxDataViewItem&amp;amp; item,
        unsigned int col,
        const wxMouseEvent *mouseEvent);

private:
    wxString m_value;
    bool m_button_clicked;
    wxRect m_cell_rect;
    GalleryListView* m_parent;

protected:
    DECLARE_DYNAMIC_CLASS_NO_COPY(wxDataViewMyButtonRenderer)
};
&lt;/code&gt;&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;
When user click one row, the ActivateCell is called, we can use some rect detect algorithm to find if the button rect is clicked.
&lt;/p&gt;

&lt;p&gt;
There is no mouse up event handler! So I have to hack, basically start a wxTimer when button clicked and draw the button up effect after about 1 second in Notify(). That's why I ask wxDataViewMyButtonRenderer to inherit from wxTimer.
&lt;/p&gt;

&lt;p&gt;
To draw the button up effect, I need ask the parent wxDataViewListCtrl to refresh itself, so that the button's Render() method has a chance to be called. That's why we need SetParent().
&lt;/p&gt;

&lt;p&gt;
Here is the part of implementation:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre&gt;&lt;code class="lang-c"&gt;bool
wxDataViewMyButtonRenderer::ActivateCell(const wxRect&amp;amp; rect,
    wxDataViewModel *model,
    const wxDataViewItem&amp;amp; item,
    unsigned int col,
    const wxMouseEvent *mouseEvent)
{
    wxDataViewListStore* store=(wxDataViewListStore*) model;

    if ( mouseEvent ) {
        if ( !wxRect(GetSize()).Contains(mouseEvent-&amp;gt;GetPosition()) ){
            return false;
        }
        wxVariant item_value_pdf;
        store-&amp;gt;GetValueByRow(item_value_pdf , store-&amp;gt;GetRow(item),0);
        wxVariant item_value_created;
        store-&amp;gt;GetValueByRow(item_value_created , store-&amp;gt;GetRow(item),1);

        m_button_clicked=true;
        m_cell_rect=rect;
    } else {
        wxLogDebug(_T("Sorry, I don't handle keyboard"));
    }

    return true;
}

bool
wxDataViewMyButtonRenderer::Render( wxRect rect, wxDC *dc, int state )
{
    wxLogDebug(_T("Render called"));
    // Ensure that the check boxes always have at least the minimal required
    // size, otherwise DrawCheckBox() doesn't really work well. If this size is
    // greater than the rect size, the checkbox will be truncated but this is a
    // lesser evil.
    wxSize size = rect.GetSize();
    size.IncTo(GetSize());
    rect.SetSize(size);

    // draw button
    if(m_button_clicked==true &amp;amp;&amp;amp; rect.Intersects(m_cell_rect)){
        //draw the button when clicked
        dc-&amp;gt;SetBrush(wxBrush(wxColour(65, 150, 65), wxBRUSHSTYLE_SOLID));
        dc-&amp;gt;SetPen( *wxBLACK_PEN );
        dc-&amp;gt;DrawRectangle(rect);

        // draw button push down effect. since we cannot detect mouse up event, we use
        // timer to draw it
        const int time_to_button_up=350;
        StartOnce(time_to_button_up);
    } else {
        // draw normal button
        dc-&amp;gt;SetBrush(wxBrush(wxColour(84, 174, 84), wxBRUSHSTYLE_SOLID));
        dc-&amp;gt;SetPen( *wxBLACK_PEN );
        dc-&amp;gt;DrawRectangle(rect);

        //draw inner white border
        rect.Deflate(1);
        dc-&amp;gt;SetPen( *wxWHITE_PEN );
        dc-&amp;gt;DrawRectangle(rect);
    }

    dc-&amp;gt;SetTextForeground(*wxWHITE);
    dc-&amp;gt;DrawLabel(m_value,wxRect(dc-&amp;gt;GetTextExtent(m_value)).CentreIn(rect));

    return true;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;/div&gt;&lt;/div&gt;</description><category>c</category><category>en</category><category>wxwidgets</category><guid>http://blog.binchen.org/posts/how-to-embed-button-in-wxdataviewlistctrl.html</guid><pubDate>Sun, 13 Apr 2014 15:39:28 GMT</pubDate></item><item><title>Start wxWidgets programming on Linux/OSX</title><link>http://blog.binchen.org/posts/start-wxwidgets-programming-on-linux.html</link><dc:creator>Chen Bin</dc:creator><description>&lt;div id="outline-container-sec-1" class="outline-2"&gt;

&lt;div class="outline-text-2" id="text-1"&gt;
&lt;p&gt;
wxWidgets 3.0.0
&lt;/p&gt;

&lt;p&gt;
WARNING: before building, please make sure remove everything in build directory, &lt;b&gt;including hidden directory&lt;/b&gt;!
&lt;/p&gt;
&lt;/div&gt;
&lt;div id="outline-container-sec-1-1" class="outline-3"&gt;
&lt;h4 id="sec-1-1"&gt;Install webkit by using Linux distribution's package manager&lt;/h4&gt;
&lt;div class="outline-text-3" id="text-1-1"&gt;
&lt;p&gt;
I need use wxWebView which dependent on webkit on Linux. The issue here is that webkit on Linux is using GTK.
&lt;/p&gt;

&lt;p&gt;
Make sure the webkit and wxWidgets are using same version of GTK.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-sec-1-2" class="outline-3"&gt;
&lt;h4 id="sec-1-2"&gt;build the source&lt;/h4&gt;
&lt;div class="outline-text-3" id="text-1-2"&gt;
&lt;p&gt;
Please note I don't use libtiff. I think libpng and libjpeg is enough.
&lt;/p&gt;
&lt;div class="org-src-container"&gt;


&lt;pre&gt;&lt;code class="lang-sh"&gt;mkdir -p ${WXWIN}/build-release;cd ${WXWIN}/build-release;../configure --disable-shared --without-libtiff;make
mkdir -p ${WXWIN}/build-debug;cd ${WXWIN}/build-debug;../configure --disable-shared --enable-debug --without-libtiff;make
&lt;/code&gt;&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;
On OSX, I need extra &lt;code&gt;--with-osx_cocoa&lt;/code&gt; parameter for configure.
&lt;/p&gt;

&lt;p&gt;
On Linux, build will be fine following above steps. But for building application, I need &lt;code&gt;sudo apt-get install libgtk2.0-dev&lt;/code&gt; on Debian/Ubuntu/Mint.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>en</category><category>linux</category><category>wxwidgets</category><guid>http://blog.binchen.org/posts/start-wxwidgets-programming-on-linux.html</guid><pubDate>Tue, 26 Feb 2013 09:17:00 GMT</pubDate></item><item><title>How to debug GTK warning</title><link>http://blog.binchen.org/posts/how-to-debug-gtk-warning.html</link><dc:creator>Chen Bin</dc:creator><description>&lt;div&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;My code (based on wxWidgets) will produce some annoying gtk warnings when debugged in gdb. The best way to debug it is &lt;code&gt;run â€“g-fatal-warnings&lt;/code&gt; in gdb. &lt;/p&gt;&lt;/div&gt;</description><category>en</category><category>gtk</category><category>wxwidgets</category><guid>http://blog.binchen.org/posts/how-to-debug-gtk-warning.html</guid><pubDate>Fri, 10 Feb 2012 14:20:34 GMT</pubDate></item></channel></rss>