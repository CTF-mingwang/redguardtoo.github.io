<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/"><channel><title>Chen's blog (Posts about flyspell)</title><link>http://blog.binchen.org/</link><description></description><atom:link href="http://blog.binchen.org/categories/flyspell.xml" type="application/rss+xml" rel="self"></atom:link><language>en</language><lastBuildDate>Thu, 28 Mar 2019 10:27:47 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>How to spell check function/variable in Emacs</title><link>http://blog.binchen.org/posts/how-to-spell-check-functionvariable-in-emacs.html</link><dc:creator>Chen Bin</dc:creator><description>&lt;div&gt;&lt;p&gt;
CREATED: &lt;span class="timestamp-wrapper"&gt;&lt;span class="timestamp"&gt;&amp;lt;2018-06-17 Sun&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;/p&gt;

&lt;p&gt;
UPDATED: &lt;span class="timestamp-wrapper"&gt;&lt;span class="timestamp"&gt;&amp;lt;2018-09-06 Thu&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;/p&gt;

&lt;p&gt;
&lt;a href="http://blog.binchen.org/posts/effective-spell-check-in-emacs.html"&gt;This article&lt;/a&gt; explains how to spell check name of function and variable while programming in Emacs.
&lt;/p&gt;

&lt;p&gt;
It uses options &lt;code&gt;--run-together&lt;/code&gt; from &lt;a href="http://aspell.net/"&gt;GNU Aspell&lt;/a&gt; to check camel cased word.
&lt;/p&gt;

&lt;p&gt;
But this solution is not perfect. It wrongly identifies two character interior word as typo. For example, "onChange" is identified as typo because the interior word "on". Another issue is namespace of function name. For example, "MS" from "MSToggleButton" is alias of "Microsoft". If "MS" is identified as typo, every word containing namespace "MS" is regarded as typo.
&lt;/p&gt;

&lt;p&gt;
In this article,
&lt;/p&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;I will explain &lt;b&gt;how Emacs spell checker works&lt;/b&gt;&lt;/li&gt;
&lt;li&gt;Then we study the &lt;b&gt;algorithm of aspell&lt;/b&gt; (We can learn nothing from hunspell because &lt;b&gt;hunspell can NOT check camel case word at all&lt;/b&gt;)&lt;/li&gt;
&lt;li&gt;Finally, I will show you &lt;b&gt;a complete solution&lt;/b&gt; which works with &lt;b&gt;either aspell or hunspell&lt;/b&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
In Emacs, a built in plugin &lt;a href="https://www.emacswiki.org/emacs/FlySpell"&gt;Fly Spell&lt;/a&gt; is in charge of spell check. It passes the options and plain text to command line tool aspell. Aspell sends back the typos of text into &lt;code&gt;Fly Spell&lt;/code&gt;. &lt;code&gt;Fly Spell&lt;/code&gt; then select certain typos to display. For example, when &lt;a href="https://www.gnu.org/software/emacs/manual/html_node/emacs/Spelling.html"&gt;flyspell-prog-mode&lt;/a&gt; is on, only typos in comments and strings are visible.
&lt;/p&gt;

&lt;p&gt;
So aspell doesn't understand syntax of any programming language. It scans plain text and report all typos to Fly Spell.
&lt;/p&gt;

&lt;p&gt;
In aspell, there are two extra "run-together" word options:
&lt;/p&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;code&gt;--run-together-limit&lt;/code&gt; is "Maximum number of words can be strung together"&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--run-together-min&lt;/code&gt; is "Minimal length of interior words"&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
Let's study the code of aspell to understand these two options. The "run-together" algorithm in implemented in function &lt;code&gt;Working::check_word&lt;/code&gt; of file "modules/speller/default/suggest.cpp".
&lt;/p&gt;

&lt;p&gt;
In order to help you understand this function, I documented the code line by line,
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre&gt;&lt;code class="lang-c"&gt;class Working : public Score {
  unsigned check_word(char * word, char * word_end, CheckInfo * ci, unsigned pos = 1);
};
unsigned Working::check_word(char * word, char * word_end,  CheckInfo * ci,
                             /* it WILL modify word */
                             unsigned pos)
{
  // check the whole word before go into run-together mode
  unsigned res = check_word_s(word, ci);
  // if `res` is true, it's a valid word, don't bother run-together
  if (res) return pos + 1;
  // it's typo because number of interior words is greater than "--run-together-limit"
  if (pos + 1 &amp;gt;= sp-&amp;gt;run_together_limit_) return 0;

  // `i` is the `end` of interior word, the poition AFTER last character of interior word
  for (char * i = word + sp-&amp;gt;run_together_min_; 
       // already checked the whole word; besides, any interior word whose size is less 
       // than "--run-together-min" is regarded as invalid
       i &amp;lt;= word_end - sp-&amp;gt;run_together_min_;
       ++i)
  {
    char t = *i;

    // read the interior word by set the character at `end` position to '\0'
    *i = '\0';
    res = check_word_s(word, ci);
    // restore original character at `end` position
    *i = t;

    // Current interior word is invalid, we need append the character at current
    //  `end` position to creata new interior word.
    //  Inncrement `i` because `i` always points to the `end` of interior word
    if (!res) continue;

    // Current interior word is valid, strip it from the whole word to create a totally
    // new word for `check_word`, `check_word` is a recursive function
    res = check_word(i, word_end, ci + 1, pos + 1);
    if (res) return res;
  }
  memset(ci, 0, sizeof(CheckInfo));
  return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;
Let's use "hisHelle" as demo how &lt;code&gt;check_word&lt;/code&gt; runs:
&lt;/p&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;"word" points to string "hisHelle" (in C/C++, string is character array. The last character of array is character '\0')&lt;/li&gt;
&lt;li&gt;"sp-&amp;gt;run_together_min_" is 3, so "i" initially points to the character "H", at the end of interior word "his"&lt;/li&gt;
&lt;li&gt;"check_word_s" return "true" for interior word "his"&lt;/li&gt;
&lt;li&gt;So we strip "his" from "hisHelle" and recursively call "check_word" to check new word "Helle"&lt;/li&gt;
&lt;li&gt;In the new context of "check_word", we extract "Hel" from "Helle" initially&lt;/li&gt;
&lt;li&gt;"Hel" is invalid. So we extract "Hell" from "Helle" and get new word "e" and recursively apply "check_word" on "e"&lt;/li&gt;
&lt;li&gt;"e" is not valid and at the end of recursion. So "hisHelle" is a typo&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
Here is our conclusion after studying the code:
&lt;/p&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;code&gt;--run-together-limit&lt;/code&gt; could not be bigger if your computer got enough memory. It's default value is 8. I prefer 16.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--run-together-min&lt;/code&gt; can't be 2 because too many typos are combination of "correct" two character interior words ("hehe", "isme", â€¦)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--run-together-min&lt;/code&gt; can't be greater than 3, or else, too many "correct" three character interior words are regarded as invalid ("his", "her", "one", "two")&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--run-together-min&lt;/code&gt; should always be 3 which is its default value. Actually, it should never be tweak-able by user at the beginning&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
Since &lt;code&gt;--run-together-min&lt;/code&gt; is 3. the word "onChange" is always regarded as typo because of two character interior word "on". Since there is nothing we can do at aspell side, we have to turn to Emacs to fix this problem.
&lt;/p&gt;

&lt;p&gt;
When Emacs got potential typo on Emacs side, we can strip out all the two character interior word from original word and spell check new word again.
&lt;/p&gt;

&lt;p&gt;
Please note &lt;code&gt;hunspell&lt;/code&gt; can't check camel case word at all while aspell can check camel case word but with a little noise. So there is nothing we can study in hunspell.
&lt;/p&gt;

&lt;p&gt;
We will use Emacs Lisp to solve this problem completely, using &lt;b&gt;either aspell or hunspell&lt;/b&gt;.
&lt;/p&gt;

&lt;p&gt;
We can attach a predicate into specific major-mode. The predicate return &lt;code&gt;t&lt;/code&gt; if current word at cursor is typo,
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre&gt;&lt;code class="lang-lisp"&gt;(defun js-flyspell-verify ()
  (let* ((font-face (get-text-property (- (point) 1) 'face))
         (word (thing-at-point 'word)))
    (message "font-face=%s word=%s" font-face word)
    t))
(put 'js2-mode 'flyspell-mode-predicate 'js-flyspell-verify)
&lt;/code&gt;&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;
As you can see from above code, we have full control on what typos should be displayed in &lt;code&gt;js-flyspell-verify&lt;/code&gt;. So &lt;code&gt;predicate&lt;/code&gt; is actually the last chance to fix wrongly identified typos.
&lt;/p&gt;

&lt;p&gt;
Here is complete setup you can paste into &lt;code&gt;.emacs&lt;/code&gt; (I setup for &lt;code&gt;js2-mode&lt;/code&gt; and &lt;code&gt;rjsx-mode&lt;/code&gt; but code is generic enough).
&lt;/p&gt;

&lt;p&gt;
Please note function &lt;code&gt;split-camel-case&lt;/code&gt; split a camel case word into a list of sub-words. I just assume any sub-word whose length is less than three is not a typo.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre&gt;&lt;code class="lang-lisp"&gt;(defun split-camel-case (word)
  "Split camel case WORD into a list of strings.
Ported from 'https://github.com/fatih/camelcase/blob/master/camelcase.go'."
  (let* ((case-fold-search nil)
         (len (length word))
         ;; ten sub-words is enough
         (runes [nil nil nil nil nil nil nil nil nil nil])
         (runes-length 0)
         (i 0)
         ch
         (last-class 0)
         (class 0)
         rlt)

    ;; split into fields based on class of character
    (while (&amp;lt; i len)
      (setq ch (elt word i))
      (cond
       ;; lower case
       ((and (&amp;gt;= ch ?a) (&amp;lt;= ch ?z))
        (setq class 1))
       ;; upper case
       ((and (&amp;gt;= ch ?A) (&amp;lt;= ch ?Z))
        (setq class 2))
       ((and (&amp;gt;= ch ?0) (&amp;lt;= ch ?9))
        (setq class 3))
       (t
        (setq class 4)))

      (cond
       ((= class last-class)
        (aset runes
              (1- runes-length)
              (concat (aref runes (1- runes-length)) (char-to-string ch))))
       (t
        (aset runes runes-length (char-to-string ch))
        (setq runes-length (1+ runes-length))))
      (setq last-class class)
      ;; end of while
      (setq i (1+ i)))

    ;; handle upper case -&amp;gt; lower case sequences, e.g.
    ;;     "PDFL", "oader" -&amp;gt; "PDF", "Loader"
    (setq i 0)
    (while (&amp;lt; i (1- runes-length))
      (let* ((ch-first (aref (aref runes i) 0))
             (ch-second (aref (aref runes (1+ i)) 0)))
        (when (and (and (&amp;gt;= ch-first ?A) (&amp;lt;= ch-first ?Z))
                   (and (&amp;gt;= ch-second ?a) (&amp;lt;= ch-second ?z)))
          (aset runes (1+ i) (concat (substring (aref runes i) -1) (aref runes (1+ i))))
          (aset runes i (substring (aref runes i) 0 -1))))
      (setq i (1+ i)))

    ;; construct final result
    (setq i 0)
    (while (&amp;lt; i runes-length)
      (when (&amp;gt; (length (aref runes i)) 0)
        (setq rlt (add-to-list 'rlt (aref runes i) t)))
      (setq i (1+ i)))
     rlt))

(defun flyspell-detect-ispell-args (&amp;amp;optional run-together)
  "If RUN-TOGETHER is true, spell check the CamelCase words.
Please note RUN-TOGETHER will make aspell less capable. So it should only be used in prog-mode-hook."
  ;; force the English dictionary, support Camel Case spelling check (tested with aspell 0.6)
  (let* ((args (list "--sug-mode=ultra" "--lang=en_US"))args)
    (if run-together
        (setq args (append args '("--run-together" "--run-together-limit=16"))))
    args))

;; {{ for aspell only, hunspell does not need setup `ispell-extra-args'
(setq ispell-program-name "aspell")
(setq-default ispell-extra-args (flyspell-detect-ispell-args t))
;; }}

;; ;; {{ hunspell setup, please note we use dictionary "en_US" here
;; (setq ispell-program-name "hunspell")
;; (setq ispell-local-dictionary "en_US")
;; (setq ispell-local-dictionary-alist
;;       '(("en_US" "[[:alpha:]]" "[^[:alpha:]]" "[']" nil ("-d" "en_US") nil utf-8)))
;; ;; }}

(defvar extra-flyspell-predicate '(lambda (word) t)
  "A callback to check WORD.  Return t if WORD is typo.")

(defun my-flyspell-predicate (word)
  "Use aspell to check WORD.  If it's typo return t."
  (let* ((cmd (cond
               ;; aspell: `echo "helle world" | aspell pipe`
               ((string-match-p "aspell$" ispell-program-name)
                (format "echo \"%s\" | %s pipe"
                        word
                        ispell-program-name))
               ;; hunspell: `echo "helle world" | hunspell -a -d en_US`
               (t
                (format "echo \"%s\" | %s -a -d en_US"
                        word
                        ispell-program-name))))
         (cmd-output (shell-command-to-string cmd))
         rlt)
    ;; (message "word=%s cmd=%s" word cmd)
    ;; (message "cmd-output=%s" cmd-output)
    (cond
     ((string-match-p "^&amp;amp;" cmd-output)
      ;; it's a typo because at least one sub-word is typo
      (setq rlt t))
     (t
      ;; not a typo
      (setq rlt nil)))
    rlt))

(defun js-flyspell-verify ()
  (let* ((case-fold-search nil)
         (font-matched (memq (get-text-property (- (point) 1) 'face)
                             '(js2-function-call
                               js2-function-param
                               js2-object-property
                               js2-object-property-access
                               font-lock-variable-name-face
                               font-lock-string-face
                               font-lock-function-name-face
                               font-lock-builtin-face
                               rjsx-text
                               rjsx-tag
                               rjsx-attr)))
         subwords
         word
         (rlt t))
    (cond
     ((not font-matched)
      (setq rlt nil))
     ;; ignore two character word
     ((&amp;lt; (length (setq word (thing-at-point 'word))) 2)
      (setq rlt nil))
     ;; handle camel case word
     ((and (setq subwords (split-camel-case word)) (&amp;gt; (length subwords) 1))
      (let* ((s (mapconcat (lambda (w)
                             (cond
                              ;; sub-word wholse length is less than three
                              ((&amp;lt; (length w) 3)
                               "")
                               ;; special characters
                              ((not (string-match-p "^[a-zA-Z]*$" w))
                               "")
                              (t
                               w))) subwords " ")))
        (setq rlt (my-flyspell-predicate s))))
     (t
      (setq rlt (funcall extra-flyspell-predicate word))))
    rlt))

(put 'js2-mode 'flyspell-mode-predicate 'js-flyspell-verify)
(put 'rjsx-mode 'flyspell-mode-predicate 'js-flyspell-verify)
&lt;/code&gt;&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;
Optionally, you could see &lt;a href="https://github.com/redguardtoo/emacs.d/blob/master/lisp/init-spelling.el"&gt;https://github.com/redguardtoo/emacs.d/blob/master/lisp/init-spelling.el&lt;/a&gt; for my real world setup.
&lt;/p&gt;

&lt;p&gt;
UPDATE:
Now you can use &lt;a href="https://github.com/redguardtoo/wucuo"&gt;wucuo&lt;/a&gt; which is complete and out of box solution to spell check code.&lt;/p&gt;&lt;/div&gt;</description><category>emacs</category><category>en</category><category>flyspell</category><guid>http://blog.binchen.org/posts/how-to-spell-check-functionvariable-in-emacs.html</guid><pubDate>Sun, 17 Jun 2018 03:16:41 GMT</pubDate></item></channel></rss>