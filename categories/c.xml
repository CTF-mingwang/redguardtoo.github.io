<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/"><channel><title>Chen's blog (c)</title><link>http://blog.binchen.org/</link><description></description><atom:link href="http://blog.binchen.org/categories/c.xml" type="application/rss+xml" rel="self"></atom:link><language>en</language><lastBuildDate>Fri, 27 Feb 2015 16:14:28 GMT</lastBuildDate><generator>http://getnikola.com/</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>How to embed button in wxDataViewListCtrl</title><link>http://blog.binchen.org/posts/how-to-embed-button-in-wxdataviewlistctrl.html</link><dc:creator>Chen Bin</dc:creator><description>&lt;div&gt;&lt;p&gt;
Before creating wxDataViewListCtrl, it's better to detect information about text size so that we can set the column width and height intelligently.
&lt;/p&gt;

&lt;p&gt;
Here is the code:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre&gt;&lt;code class="lang-c"&gt;
void GuessRowSize(int* w, int* h) {
    //@see http://sourceforge.net/apps/trac/codelite/browser/trunk/LiteEditor/new_build_tab.cpp?rev=5804

// Determine the row height
    wxBitmap tmpBmp(1, 1);
    wxMemoryDC memDc;
    memDc.SelectObject(tmpBmp);
    wxFont f = wxSystemSettings::GetFont(wxSYS_ANSI_FIXED_FONT);
    int xx, yy;
    memDc.GetTextExtent(wxT("Tp"), &amp;amp;xx, &amp;amp;yy, NULL, NULL, &amp;amp;f);

    //enough height for ICON
    *h=yy&amp;lt;16? 16: yy;

    memDc.GetTextExtent("Wp", &amp;amp;xx, &amp;amp;yy, NULL, NULL, &amp;amp;f);
    *w=xx/2;

    return;
}
wxDataViewListCtrl* ctrl=new wxDataViewListCtrl(parent,-1);
ctrl-&amp;gt;Create(parent,id,wxDefaultPosition,wxDefaultSize);
int w,h;
GuessRowSize(&amp;amp;w,&amp;amp;h);
//hard code width may not be good, may be can use w ,h
AppendTextColumn(_T("Column 1"),wxDATAVIEW_CELL_INERT,200 /*width*/);
//must be called after Create()
ctrl-&amp;gt;SetRowHeight(h+6);


// well I need provide button render by myself
class wxDataViewMyButtonRenderer: public wxDataViewCustomRenderer, public wxTimer
{
public:
    wxDataViewMyButtonRenderer( const wxString &amp;amp;varianttype = wxT("wxString"),
                              int align = wxDVR_DEFAULT_ALIGNMENT );

    virtual bool SetValue( const wxVariant &amp;amp;value );
    virtual bool GetValue( wxVariant &amp;amp;value ) const;

    virtual bool Render( wxRect, wxDC*, int);
    virtual wxSize GetSize() const;
    virtual void Notify();
    void SetParent(GalleryListView*);
    // Implementation only, don't use nor override
    virtual bool ActivateCell(const wxRect&amp;amp; rect,
        wxDataViewModel *model,
        const wxDataViewItem&amp;amp; item,
        unsigned int col,
        const wxMouseEvent *mouseEvent);

private:
    wxString m_value;
    bool m_button_clicked;
    wxRect m_cell_rect;
    GalleryListView* m_parent;

protected:
    DECLARE_DYNAMIC_CLASS_NO_COPY(wxDataViewMyButtonRenderer)
};
&lt;/code&gt;&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;
When user click one row, the ActivateCell is called, we can use some rect detect algorithm to find if the button rect is clicked.
&lt;/p&gt;

&lt;p&gt;
There is no mouse up event handler! So I have to hack, basically start a wxTimer when button clicked and draw the button up effect after about 1 second in Notify(). That's why I ask wxDataViewMyButtonRenderer to inherit from wxTimer.
&lt;/p&gt;

&lt;p&gt;
To draw the button up effect, I need ask the parent wxDataViewListCtrl to refresh itself, so that the button's Render() method has a chance to be called. That's why we need SetParent().
&lt;/p&gt;

&lt;p&gt;
Here is the part of implementation:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre&gt;&lt;code class="lang-c"&gt;
bool
wxDataViewMyButtonRenderer::ActivateCell(const wxRect&amp;amp; rect,
    wxDataViewModel *model,
    const wxDataViewItem&amp;amp; item,
    unsigned int col,
    const wxMouseEvent *mouseEvent)
{
    wxDataViewListStore* store=(wxDataViewListStore*) model;

    if ( mouseEvent ) {
        if ( !wxRect(GetSize()).Contains(mouseEvent-&amp;gt;GetPosition()) ){
            return false;
        }
        wxVariant item_value_pdf;
        store-&amp;gt;GetValueByRow(item_value_pdf , store-&amp;gt;GetRow(item),0);
        wxVariant item_value_created;
        store-&amp;gt;GetValueByRow(item_value_created , store-&amp;gt;GetRow(item),1);

        m_button_clicked=true;
        m_cell_rect=rect;
    } else {
        wxLogDebug(_T("Sorry, I don't handle keyboard"));
    }

    return true;
}

bool
wxDataViewMyButtonRenderer::Render( wxRect rect, wxDC *dc, int state )
{
    wxLogDebug(_T("Render called"));
    // Ensure that the check boxes always have at least the minimal required
    // size, otherwise DrawCheckBox() doesn't really work well. If this size is
    // greater than the rect size, the checkbox will be truncated but this is a
    // lesser evil.
    wxSize size = rect.GetSize();
    size.IncTo(GetSize());
    rect.SetSize(size);

    // draw button
    if(m_button_clicked==true &amp;amp;&amp;amp; rect.Intersects(m_cell_rect)){
        //draw the button when clicked
        dc-&amp;gt;SetBrush(wxBrush(wxColour(65, 150, 65), wxBRUSHSTYLE_SOLID));
        dc-&amp;gt;SetPen( *wxBLACK_PEN );
        dc-&amp;gt;DrawRectangle(rect);

        // draw button push down effect. since we cannot detect mouse up event, we use
        // timer to draw it
        const int time_to_button_up=350;
        StartOnce(time_to_button_up);
    } else {
        // draw normal button
        dc-&amp;gt;SetBrush(wxBrush(wxColour(84, 174, 84), wxBRUSHSTYLE_SOLID));
        dc-&amp;gt;SetPen( *wxBLACK_PEN );
        dc-&amp;gt;DrawRectangle(rect);

        //draw inner white border
        rect.Deflate(1);
        dc-&amp;gt;SetPen( *wxWHITE_PEN );
        dc-&amp;gt;DrawRectangle(rect);
    }

    dc-&amp;gt;SetTextForeground(*wxWHITE);
    dc-&amp;gt;DrawLabel(m_value,wxRect(dc-&amp;gt;GetTextExtent(m_value)).CentreIn(rect));

    return true;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;/div&gt;&lt;/div&gt;</description><category>c</category><category>en</category><category>wxwidgets</category><guid>http://blog.binchen.org/posts/how-to-embed-button-in-wxdataviewlistctrl.html</guid><pubDate>Sun, 13 Apr 2014 15:39:28 GMT</pubDate></item><item><title>Make Emacs support auto-completion for CMake</title><link>http://blog.binchen.org/posts/make-emacs-support-auto-completion-for-cmake.html</link><dc:creator>Chen Bin</dc:creator><description>&lt;div&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Easy. You only install company-mode and company-cmake.el according to the documentation &lt;a href="https://github.com/company-mode/company-cmake"&gt;HERE&lt;/a&gt;. &lt;/p&gt; &lt;p&gt; company-cmake.el is written by me. I'm in the process of signing necessary copyright papers to make it part of company-mode. I was told the process could take one month because I'm deal with GNU foundation. So please be patient. &lt;/p&gt; &lt;p&gt; Anyway, you can use company-cmake.el right now with company-mode without any problem. &lt;/p&gt; &lt;p&gt; Please note I only tested this plugin with cmake 2.8. &lt;/p&gt; &lt;p&gt; Here is screen shot: &lt;img src="http://blog.binchen.org/wp-content/uploads/2014/01/company-cmake-nq8.png" alt="http://blog.binchen.org/wp-content/uploads/2014/01/company-cmake-nq8.png"&gt; &lt;/p&gt; &lt;p&gt; UPDATED (12th Jan, 2014): Legal procedure is done. Now company-cmake.el is officially part of company-mode since version 0.6.12. &lt;/p&gt; &lt;p&gt; So all you need to do is install latest company-mode, no other set up required! &lt;/p&gt;&lt;/div&gt;</description><category>c</category><category>cmake</category><category>emacs</category><category>en</category><guid>http://blog.binchen.org/posts/make-emacs-support-auto-completion-for-cmake.html</guid><pubDate>Mon, 22 Apr 2013 10:48:00 GMT</pubDate></item></channel></rss>