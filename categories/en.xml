<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/"><channel><title>Chen's blog (en)</title><link>http://blog.binchen.org/</link><description></description><atom:link href="http://blog.binchen.org/categories/en.xml" type="application/rss+xml" rel="self"></atom:link><language>en</language><lastBuildDate>Tue, 11 Aug 2015 21:17:44 GMT</lastBuildDate><generator>http://getnikola.com/</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Evil text object to select nearby file path</title><link>http://blog.binchen.org/posts/evil-text-object-to-select-nearby-file-path.html</link><dc:creator>Chen Bin</dc:creator><description>&lt;div&gt;&lt;p&gt;Insert below code into ~/.emacs:
&lt;/p&gt;

&lt;pre&gt;&lt;code class="lang-lisp"&gt;;; {{ nearby file path as text object,
;;      - "vif" to select only basename
;;      - "vaf" to select the full path
;;
;;  example: "/hello/world" "/test/back.exe"
;;               "C:hello\\hello\\world\\test.exe" "D:blah\\hello\\world\\base.exe"
;;
;; tweak evil-filepath-is-nonname to re-define a path
(defun evil-filepath-is-separator-char (ch)
  "Check ascii table"
  (let (rlt)
    (if (or (= ch 47)
            (= ch 92))
        (setq rlt t))
    rlt))

(defun evil-filepath-not-path-char (ch)
  "Check ascii table for charctater "
  (let (rlt)
    (if (or (and (&amp;lt;= 0 ch) (&amp;lt;= ch 32))
            (= ch 34) ; double quotes
            (and (&amp;lt;= 59 ch) (&amp;lt;= ch 63))
            (= 127 ch))
        (setq rlt t))
    rlt))

(defun evil-filepath-calculate-path (b e)
  (let (rlt f)
    (when (and b e)
      (setq b (+ 1 b))
      (when (save-excursion
                (goto-char e)
                (setq f (evil-filepath-search-forward-char 'evil-filepath-is-separator-char t))
                (and f (&amp;gt;= f b)))
        (setq rlt (list b (+ 1 f) (- e 1)))))
    rlt))

(defun evil-filepath-get-path-already-inside ()
  (let (b e)
    (save-excursion
      (setq b (evil-filepath-search-forward-char 'evil-filepath-not-path-char t)))
    (save-excursion
      (setq e (evil-filepath-search-forward-char 'evil-filepath-not-path-char)))
    (evil-filepath-calculate-path b e)))

(defun evil-filepath-search-forward-char (fn &amp;amp;optional backward)
  (let (found rlt)
    (save-excursion
      (while (or (= (point) (if backward (point-min) (point-max)))
                 (not (setq found (apply fn (list (following-char))))))
        (if backward (backward-char) (forward-char)))
      (if found (setq rlt (point))))
    rlt))

(defun evil-filepath-extract-region ()
  "Find the closest file path"
  (let (rlt
        b
        f1
        f2)

    (if (and (not (evil-filepath-not-path-char (following-char)))
             (setq rlt (evil-filepath-get-path-already-inside)))
        ;; maybe (point) is in the middle of the path
        t
      ;; need search forward AND backward to find the right path
      (save-excursion
        ;; path in backward direction
        (when (setq b (evil-filepath-search-forward-char 'evil-filepath-is-separator-char t))
          (goto-char b)
          (setq f1 (evil-filepath-get-path-already-inside))))
      (save-excursion
        ;; path in forward direction
        (when (setq b (evil-filepath-search-forward-char 'evil-filepath-is-separator-char))
          (goto-char b)
          (setq f2 (evil-filepath-get-path-already-inside))))
      ;; pick one path as the final result
      (cond
       ((and f1 f2)
        (if (&amp;gt; (- (point) (nth 2 f1)) (- (nth 0 f2) (point)))
            (setq rlt f2)
          (setq rlt f1)))
       (f1
        (setq rlt f1))
       (f2
        (setq rlt f2))))

    rlt))

(evil-define-text-object evil-filepath-inner-text-object (&amp;amp;optional count begin end type)
  "File name of nearby path"
  (let ((selected-region (evil-filepath-extract-region)))
    (if selected-region
        (evil-range (nth 1 selected-region) (nth 2 selected-region) :expanded t))))

(evil-define-text-object evil-filepath-outer-text-object (&amp;amp;optional NUM begin end type)
  "Nearby path"
  (let ((selected-region (evil-filepath-extract-region)))
    (if selected-region
        (evil-range (car selected-region) (+ 1 (nth 2 selected-region)) type :expanded t))))

(define-key evil-inner-text-objects-map "f" 'evil-filepath-inner-text-object)
(define-key evil-outer-text-objects-map "f" 'evil-filepath-outer-text-object)
;; }}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description><category>emacs</category><category>en</category><category>evil</category><guid>http://blog.binchen.org/posts/evil-text-object-to-select-nearby-file-path.html</guid><pubDate>Sat, 08 Aug 2015 13:16:39 GMT</pubDate></item><item><title>Use which-func-mode with js2-mode</title><link>http://blog.binchen.org/posts/use-which-func-mode-with-js2-mode.html</link><dc:creator>Chen Bin</dc:creator><description>&lt;div&gt;&lt;p&gt;Two years ago in my article "&lt;a href="http://blog.binchen.org/posts/why-emacs-is-better-editor.html"&gt;Why Emacs is better editor - a case study for javascript developer&lt;/a&gt;" I proved that Emacs is a better javascript editor because its &lt;a href="https://github.com/mooz/js2-mode"&gt;js2-mode&lt;/a&gt; can parse the tags ) in opened file more intelligently.
&lt;/p&gt;

&lt;p&gt;
Since then, the js2-mode keeps improving and becomes better every day. I'm absolutely satisfied with it except one minor issue.
&lt;/p&gt;

&lt;p&gt;
For performance reason, js2-mode place the &lt;a href="http://emacswiki.org/emacs/ImenuMode"&gt;imenu&lt;/a&gt; results into a cache which is updated by a timer.
&lt;/p&gt;

&lt;p&gt;
`(which-function)` from &lt;a href="http://www.emacswiki.org/emacs/WhichFuncMode"&gt;which-func-mode&lt;/a&gt; takes advantage of the imenu results. So the result of `(which-function)` may be incorrect if the cache is not updated by timer.
&lt;/p&gt;

&lt;p&gt;
The solution is to re-define a `my-which-function`:
&lt;/p&gt;

&lt;pre&gt;&lt;code class="lang-lisp"&gt;(defun my-which-function ()
  ;; clean the imenu cache
  ;; @see http://stackoverflow.com/questions/13426564/how-to-force-a-rescan-in-imenu-by-a-function
  (setq imenu--index-alist nil)
  (which-function))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;
The new API is very useful when I use &lt;a href="https://github.com/capitaomorte/yasnippet"&gt;yasnippet&lt;/a&gt; to insert logging code in javascript file.
&lt;/p&gt;

&lt;p&gt;
Here is a sample (log-which-func.yasnippet):
&lt;/p&gt;

&lt;pre&gt;&lt;code class="lang-snippet"&gt;# -*- coding: utf-8; mode: snippet -*-
# name: console.log which function called
# key: lwf
# --
console.log('${1:`(my-which-function)`} called');
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description><category>emacs</category><category>en</category><category>javascript</category><guid>http://blog.binchen.org/posts/use-which-func-mode-with-js2-mode.html</guid><pubDate>Mon, 03 Aug 2015 12:08:29 GMT</pubDate></item><item><title>Emacs speed up 1000%</title><link>http://blog.binchen.org/posts/emacs-speed-up-1000.html</link><dc:creator>Chen Bin</dc:creator><description>&lt;div&gt;&lt;p&gt;I'm still &lt;b&gt;NOT&lt;/b&gt; satisfied with my Emacs performance after applying below tricks:
&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;autoload packages
&lt;/li&gt;
&lt;li&gt;idle-load packages 
&lt;/li&gt;
&lt;li&gt;compiling *.el to  *.elc
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;
After some research, I found I could make my Emacs 1000% fast &lt;b&gt;in 1 minute&lt;/b&gt;.
&lt;/p&gt;

&lt;p&gt;
Please note I'm talking about the &lt;b&gt;general performance&lt;/b&gt; not just startup time.
&lt;/p&gt;

&lt;p&gt;
The solution is really simple.
&lt;/p&gt;

&lt;p&gt;
Since I'm a Linux guy and my computer got enough (24G) memory. I can place my setup on &lt;a href="http://en.wikipedia.org/wiki/Tmpfs"&gt;memory&lt;/a&gt; only.
&lt;/p&gt;

&lt;p&gt;
&lt;b&gt;Step 1&lt;/b&gt;, insert below line into /etc/fstab and restart computer:
&lt;/p&gt;

&lt;pre&gt;&lt;code class="lang-conf"&gt;tmpfs       /tmp        tmpfs       nodev,nosuid,size=8G    0   0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;
&lt;b&gt;Step 2&lt;/b&gt;, run the script "emacs2ram":
&lt;/p&gt;

&lt;pre&gt;&lt;code class="lang-bash"&gt;#!/bin/sh

if [ -z "$1" ];then
    echo "Usage:"
    echo "  emacs2ram start"
    echo "  emacs2ram restore"
    exit 1
fi

if [ "$1" == "start" ];then
    backup=emacs.d-backup
    link=.emacs.d
    volatile=/tmp/.emacs.d-$USER

    IFS=
    set -efu

    cd ~/

    if [ ! -r $volatile ]; then
        mkdir -m0700 $volatile
    fi

    # link -&amp;gt; volatie does not exist
    if [ "$(readlink $link)" != "$volatile" ]; then
        # backup project at first
        mv $link $backup
        # create the link
        ln -s $volatile $link
    fi

    if [ -e $link/.unpacked ]; then
        echo "Sync .emacs.d from memory to backup ..."
        rsync -avq --delete --exclude .unpacked ./$link/ ./$backup/
        echo "DONE!"
    else
        echo "Sync .emacs.d from disk to memory ..."
        rsync -avq ./$backup/ ./$link/
        touch $link/.unpacked
        echo "DONE!"
    fi
else
    echo "Moving .emacs.d back to disk ..."
    backup=$2-backup
    link=$2
    volatile=/tmp/$2-$USER
    cd ~/projs
    rm $link &amp;amp;&amp;amp; mv $backup $link &amp;amp;&amp;amp; rm -rf $volatile
    echo "DONE!"
fi
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;
That's all! Please enjoy Emacs as usual.
&lt;/p&gt;

&lt;p&gt;
The original script is from ArchLinux Wiki. I learned this technique eight years ago. I'm just wondering why I need eight years to apply it?
&lt;/p&gt;

&lt;p&gt;
BTW, I've also moved &lt;b&gt;all my projects into memory&lt;/b&gt;, using similar scripts.
&lt;/p&gt;

&lt;p&gt;
UPDATE:
I also publicize my project-managing script at &lt;a href="https://gist.github.com/redguardtoo/596b1a9fd3eac1cedd13#file-proj2ram"&gt;gist&lt;/a&gt;. It's almost same as emacs2ram. 
&lt;/p&gt;&lt;/div&gt;</description><category>emacs</category><category>en</category><category>linux</category><guid>http://blog.binchen.org/posts/emacs-speed-up-1000.html</guid><pubDate>Fri, 08 May 2015 11:58:13 GMT</pubDate></item><item><title>Use git-timemachine with Evil</title><link>http://blog.binchen.org/posts/use-git-timemachine-with-evil.html</link><dc:creator>Chen Bin</dc:creator><description>&lt;div&gt;&lt;p&gt;&lt;a href="https://github.com/pidu/git-timemachine"&gt;git-timemachine&lt;/a&gt; is simple.
&lt;/p&gt;

&lt;p&gt;
After "M-x git-timemachine", a new read-only buffer is created and I need only use six key bindings: "n", "q", "p", "w", "W", "g".
&lt;/p&gt;

&lt;p&gt;
The problem is I'm using &lt;a href="http://www.emacswiki.org/emacs/Evil"&gt;Evil&lt;/a&gt;. How to make git-timemachine's key bindings override Evil's?
&lt;/p&gt;

&lt;p&gt;
I consulted the issue with Frank Fischer.
&lt;/p&gt;

&lt;p&gt;
The solution is simple. Insert below code into ~/.emacs:
&lt;/p&gt;

&lt;pre&gt;&lt;code class="lang-lisp"&gt;;; @see https://bitbucket.org/lyro/evil/issue/511/let-certain-minor-modes-key-bindings
(eval-after-load 'git-timemachine
  '(progn
     (evil-make-overriding-map git-timemachine-mode-map 'normal)
     ;; force update evil keymaps after git-timemachine-mode loaded
     (add-hook 'git-timemachine-mode-hook #'evil-normalize-keymaps)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;
I also recommend reading &lt;a href="https://bitbucket.org/lyro/evil/issue/511/let-certain-minor-modes-key-bindings"&gt;his in-depth discussion&lt;/a&gt; on &lt;b&gt;general handling of keybindings conflict&lt;/b&gt; between evil and other minor modes.
&lt;/p&gt;&lt;/div&gt;</description><category>emacs</category><category>en</category><category>git</category><guid>http://blog.binchen.org/posts/use-git-timemachine-with-evil.html</guid><pubDate>Thu, 09 Apr 2015 23:47:41 GMT</pubDate></item><item><title>Code search in Emacs</title><link>http://blog.binchen.org/posts/code-search-in-emacs.html</link><dc:creator>Chen Bin</dc:creator><description>&lt;div&gt;&lt;p&gt;After shutdown of &lt;a href="http://en.wikipedia.org/wiki/Google_Code_Search"&gt;Google Code Search&lt;/a&gt;, I turned to plain google search instead.
&lt;/p&gt;

&lt;p&gt;
For example, if I want to search Emacs Lisp code. I google "keyword filetype:el".
&lt;/p&gt;

&lt;p&gt;
"el" is the file extension of Emacs Lisp file.
&lt;/p&gt;

&lt;p&gt;
Since I use Emacs for everything, it's natural to search code in Emacs.
&lt;/p&gt;

&lt;p&gt;
So here is my solution.
&lt;/p&gt;

&lt;p&gt;
Step 1, install &lt;a href="http://w3m.sourceforge.net/"&gt;w3m&lt;/a&gt; and &lt;a href="http://melpa.org/#/w3m"&gt;its Emacs wrapper&lt;/a&gt;.
&lt;/p&gt;

&lt;p&gt;
Step 2, insert below code into ~/.emacs:
&lt;/p&gt;

&lt;pre&gt;&lt;code class="lang-lisp"&gt;(defun w3m-get-url-from-search-engine-alist (k l)
  (let (rlt)
    (if (listp l)
      (if (string= k (caar l))
          (setq rlt (nth 1 (car l)))
        (setq rlt (w3m-get-url-from-search-engine-alist k (cdr l)))))
    rlt))

(defun w3m-set-url-from-search-engine-alist (k l url)
    (if (listp l)
      (if (string= k (caar l))
          (setcdr (car l) (list url))
        (w3m-set-url-from-search-engine-alist k (cdr l) url))))

;; C-u S g RET &amp;lt;search term&amp;gt; RET in w3m
(setq w3m-search-engine-alist
      '(("g" "http://www.google.com.au/search?q=%s" utf-8)
        ;; stackoverflow search
        ("q" "http://www.google.com.au/search?q=%s+site:stackoverflow.com" utf-8)
        ;; elisp code search
        ("s" "http://www.google.com.au/search?q=%s+filetype:el"  utf-8)
        ;; wikipedia
        ("w" "http://en.wikipedia.org/wiki/Special:Search?search=%s" utf-8)
        ;; online dictionary
        ("d" "http://dictionary.reference.com/search?q=%s" utf-8)
        ;; javascript search on mozilla.org
        ("j" "http://www.google.com.au/search?q=%s+site:developer.mozilla.org" utf-8)))

(defun w3m-google-by-filetype ()
  (interactive)
  (unless (featurep 'w3m)
    (require 'w3m))
  (let ((thing (if (region-active-p)
                   (buffer-substring-no-properties (region-beginning) (region-end))
                 (thing-at-point 'symbol)))
        (old-url (w3m-get-url-from-search-engine-alist "s" w3m-search-engine-alist))
        new-url)
    (when buffer-file-name
      (setq new-url (replace-regexp-in-string
                     "filetype:.*"
                     (concat "filetype:" (file-name-extension buffer-file-name))
                     old-url))
      (w3m-set-url-from-search-engine-alist "s" w3m-search-engine-alist new-url))
    ;; change the url to search current file type
    (w3m-search "s" thing)
    ;; restore the default url
    (w3m-set-url-from-search-engine-alist "s" w3m-search-engine-alist old-url)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;
Step 3, `M-x w3m-google-by-filetype`. Either the selected region or the symbol under cursor will be searched.
&lt;/p&gt;&lt;/div&gt;</description><category>emacs</category><category>en</category><category>search</category><guid>http://blog.binchen.org/posts/code-search-in-emacs.html</guid><pubDate>Wed, 08 Apr 2015 13:09:40 GMT</pubDate></item><item><title>Use plain Vim to merge conflicts</title><link>http://blog.binchen.org/posts/use-plain-vim-to-merge-conflicts.html</link><dc:creator>Chen Bin</dc:creator><description>&lt;div&gt;&lt;p&gt;I will explain how to resolve code merge conflicts with plain vim. The only third party plugin required is &lt;a href="https://github.com/tpope/vim-unimpaired"&gt;vim-unimpaired&lt;/a&gt;.
&lt;/p&gt;

&lt;p&gt;
The reason to use vim is that I can't use vimdiff as a merge tool for certain VCS (CVS, Subversion, Perforce, …).
&lt;/p&gt;

&lt;div id="outline-container-1" class="outline-3"&gt;
&lt;h4 id="sec-1"&gt;Problem&lt;/h4&gt;
&lt;div class="outline-text-3" id="text-1"&gt;

&lt;p&gt;A typical file in conflict is like:
&lt;/p&gt;



&lt;pre&gt;&lt;code class="lang-diff"&gt;hello world
hello world
&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt; .mine
This is fun stuff!
=======
This is a documentation file
&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; .r6
bye world
bye world
&lt;/code&gt;&lt;/pre&gt;



&lt;p&gt;
Let's call lines like "&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;", "&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;" and "=======" conflict markers.
&lt;/p&gt;
&lt;p&gt;
Resolving conflicts is the operation of picking up &lt;b&gt;either or both&lt;/b&gt; of the sections between markers.
&lt;/p&gt;
&lt;/div&gt;

&lt;/div&gt;

&lt;div id="outline-container-2" class="outline-3"&gt;
&lt;h4 id="sec-2"&gt;Basic knowledge of Vim&lt;/h4&gt;
&lt;div class="outline-text-3" id="text-2"&gt;

&lt;ul&gt;&lt;li&gt;"]n" move the focus to the next marker and "[n" to the previous marker.
&lt;/li&gt;
&lt;li&gt;"dd" delete current line
&lt;/li&gt;
&lt;li&gt;"d]n" delete from current line to the next marker (next marker exclusive)
&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;div id="outline-container-3" class="outline-3"&gt;
&lt;h4 id="sec-3"&gt;Solution&lt;/h4&gt;
&lt;div class="outline-text-3" id="text-3"&gt;

&lt;p&gt;Our workflow is actually simple:
&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Step 1, find the next marker by pressing "]n"
&lt;/li&gt;
&lt;li&gt;Step 2, "]nd]n[ndd[ndd" to pick up the section 1
&lt;/li&gt;
&lt;li&gt;Step 3, "d]ndd]ndd" to pick up  the section 2, go to step 1
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;
This workflow is compatible with any version control software.
&lt;/p&gt;
&lt;p&gt;
&lt;b&gt;Optionally&lt;/b&gt; you can set the shortcut for step 2 and step 3:
&lt;/p&gt;



&lt;pre&gt;&lt;code class="lang-vimrc"&gt;map &amp;lt;leader&amp;gt;dg1 ]nd]n[ndd[ndd
map &amp;lt;leader&amp;gt;dg2 d]ndd]ndd
&lt;/code&gt;&lt;/pre&gt;


&lt;/div&gt;

&lt;/div&gt;&lt;/div&gt;</description><category>en</category><category>vim</category><guid>http://blog.binchen.org/posts/use-plain-vim-to-merge-conflicts.html</guid><pubDate>Tue, 07 Apr 2015 07:19:37 GMT</pubDate></item><item><title>Easy indentation setup in Emacs for web development</title><link>http://blog.binchen.org/posts/easy-indentation-setup-in-emacs-for-web-development.html</link><dc:creator>Chen Bin</dc:creator><description>&lt;div&gt;&lt;p&gt;Because I've been asked on this issue so many times, I will anwser here once for all.
&lt;/p&gt;

&lt;p&gt;
Insert below code into ~/.emacs:
&lt;/p&gt;

&lt;pre&gt;&lt;code class="lang-lisp"&gt;(defun my-setup-indent (n)
  ;; web development
  (setq coffee-tab-width n) ; coffeescript
  (setq javascript-indent-level n) ; javascript-mode
  (setq js-indent-level n) ; js-mode
  (setq js2-basic-offset n) ; js2-mode
  (setq web-mode-markup-indent-offset n) ; web-mode, html tag in html file
  (setq web-mode-css-indent-offset n) ; web-mode, css in html file
  (setq web-mode-code-indent-offset n) ; web-mode, js code in html file
  (setq css-indent-offset n) ; css-mode
  )

(defun my-office-code-style ()
  (interactive)
  (message "Office code style!")
  (setq indent-tabs-mode t) ; use tab instead of space
  (my-setup-indent 4) ; indent 4 spaces width
  )

(defun my-personal-code-style ()
  (interactive)
  (message "My personal code style!")
  (setq indent-tabs-mode nil) ; use space instead of tab
  (my-setup-indent 2) ; indent 2 spaces width
  )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;
Combine above functions with `prog-mode-hook` and `buffer-file-name`, you can do the per project setup easily.
&lt;/p&gt;

&lt;p&gt;
I do this thing when switching project. It takes me &lt;b&gt;no more than one minute&lt;/b&gt;. Since my project last at least three months, one minute is not a big deal.
&lt;/p&gt;&lt;/div&gt;</description><category>emacs</category><category>en</category><category>indent</category><category>web</category><guid>http://blog.binchen.org/posts/easy-indentation-setup-in-emacs-for-web-development.html</guid><pubDate>Thu, 02 Apr 2015 13:57:48 GMT</pubDate></item><item><title>Effective code navigation for web development</title><link>http://blog.binchen.org/posts/effective-code-navigation-for-web-development.html</link><dc:creator>Chen Bin</dc:creator><description>&lt;div&gt;&lt;p&gt;I use &lt;a href="https://angularjs.org/"&gt;AngularJS&lt;/a&gt; as an example. The technique applies to other web frameworks.
&lt;/p&gt;

&lt;div id="outline-container-1" class="outline-3"&gt;
&lt;h4 id="sec-1"&gt;Problem&lt;/h4&gt;
&lt;div class="outline-text-3" id="text-1"&gt;

&lt;p&gt;In Angular application, a function is defined in a javascript file and called in a html file.
&lt;/p&gt;
&lt;p&gt;
javascript file:
&lt;/p&gt;



&lt;pre&gt;&lt;code class="lang-html"&gt;&amp;lt;div ng-controller="MyController" ng-init="init()"&amp;gt;
  &amp;lt;button ng-click="onClick()"&amp;gt;&amp;lt;/button&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;



&lt;p&gt;
html file:
&lt;/p&gt;



&lt;pre&gt;&lt;code class="lang-javascript"&gt;angular.module['myapp'].controller('MyController', function ($scope, $http) {

  $scope.init = function () {
  };

  $scope.onClick= function() {
  };
});
&lt;/code&gt;&lt;/pre&gt;



&lt;p&gt;
As you can see, the keyword we are interested is just a string, like "MyController". The only way to extract it is &lt;b&gt;regular expression&lt;/b&gt;.
&lt;/p&gt;
&lt;/div&gt;

&lt;/div&gt;

&lt;div id="outline-container-2" class="outline-3"&gt;
&lt;h4 id="sec-2"&gt;Solution&lt;/h4&gt;
&lt;div class="outline-text-3" id="text-2"&gt;

&lt;p&gt;CTags is good at parsing files with &lt;b&gt;regular expression&lt;/b&gt;.
&lt;/p&gt;
&lt;p&gt;
I use CTags instead of IDEs because:
&lt;/p&gt;&lt;ul&gt;&lt;li&gt;New web frameworks keep popping up. I don't want to waste time&amp;amp;money on upgrading IDE frequently
&lt;/li&gt;
&lt;li&gt;As a freelancer, I have to deal with in-house frameworks which IDE developers NEVER heard of
&lt;/li&gt;
&lt;li&gt;Setup of ctags and text editors is easy. Once the first project is set up, others are just five minutes of copy&amp;amp;paste jobs.
&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;

&lt;div id="outline-container-2-1" class="outline-4"&gt;
&lt;h5 id="sec-2-1"&gt;CTags setup&lt;/h5&gt;
&lt;div class="outline-text-4" id="text-2-1"&gt;

&lt;p&gt;Create a file named ".ctags":
&lt;/p&gt;



&lt;pre&gt;&lt;code class="lang-conf"&gt;--langdef=html
--langmap=html:.htm.html.erb
--regex-html=/[ \t]+id[ \t]*=[ \t]*['"]([^'"]+)/\1/o,object/
--regex-html=/[ \t]+ng-controller[ \t]*=[ \t]*['"]([^'"]+)/\1/o,object/
--regex-html=/[ \t]+ng-click[ \t]*=[ \t]*['"]([^'"]+)/\1/o,object/
--regex-html=/[ \t]+ng-change[ \t]*=[ \t]*['"]([^'"]+)/\1/o,object/
--regex-html=/[ \t]+ng-show[ \t]*=[ \t]*['"]([^'"]+)/\1/o,object/
--regex-html=/[ \t]+ng-if[ \t]*=[ \t]*['"]([^'"]+)/\1/o,object/
--regex-html=/[ \t]+ng-blur[ \t]*=[ \t]*['"]([^'"]+)/\1/o,object/
--regex-html=/[ \t]+ng-focus[ \t]*=[ \t]*['"]([^'"]+)/\1/o,object/
--regex-html=/[ \t]+ng-disabled[ \t]*=[ \t]*['"]([^'"]+)/\1/o,object/
--regex-html=/[ \t]+ng-repeat[ \t]*=[ \t]*['"][^'"]+ in \([^'"]+\)['"]/\1/o,object/

--langdef=js
--langmap=js:.js
--regex-js=/\$scope\.([A-Za-z0-9._\$]+)[ \t]*[:=]/\1/,variable/
--regex-js=/\.controller[ \t]*\([ \t]*['"]([A-Za-z0-9_$.]+)['"][ \t]*,/\1/,controller/
--regex-js=/\.filter[ \t]*\([ \t]*['"]([A-Za-z0-9_$.]+)['"][ \t]*,/\1/,filter/
--regex-js=/\.factory[ \t]*\([ \t]*['"]([A-Za-z0-9_$.]+)['"][ \t]*,/\1/,factory/
--regex-js=/\.service[ \t]*\([ \t]*['"]([A-Za-z0-9_$.]+)['"][ \t]*,/\1/,service/
--regex-js=/\.directive[ \t]*\([ \t]*['"]([A-Za-z0-9_$.]+)['"][ \t]*,/\1/,directive/
--regex-js=/.*[.][\s]*module\(['"]([a-zA-Z0-9_.]+)['"]/\1/m,module/
--regex-js=/[.](when\(['"][a-zA-Z0-9_\/]+['"])/\1/r,ngRoute/
--regex-js=/(,|(;|^)[ \t]*(var|let|([A-Za-z_$][A-Za-z0-9_$.]+\.)*))[ \t]*([A-Za-z0-9_$]+)[ \t]*=[ \t]*\{/\5/,object/
--regex-js=/(,|(;|^)[ \t]*(var|let|([A-Za-z_$][A-Za-z0-9_$.]+\.)*))[ \t]*([A-Za-z0-9_$]+)[ \t]*=[ \t]*function[ \t]*\(/\5/,function/
--regex-js=/(,|(;|^)[ \t]*(var|let|([A-Za-z_$][A-Za-z0-9_$.]+\.)*))[ \t]*([A-Za-z0-9_$]+)[ \t]*=[ \t]*\[/\5/,array/
--regex-js=/(,|(;|^)[ \t]*(var|let|([A-Za-z_$][A-Za-z0-9_$.]+\.)*))[ \t]*([A-Za-z0-9_$]+)[ \t]*=[ \t]*[^"]'[^']*/\5/,string/
--regex-js=/(,|(;|^)[ \t]*(var|let|([A-Za-z_$][A-Za-z0-9_$.]+\.)*))[ \t]*([A-Za-z0-9_$]+)[ \t]*=[ \t]*(true|false)/\5/,boolean/
--regex-js=/(,|(;|^)[ \t]*(var|let|([A-Za-z_$][A-Za-z0-9_$.]+\.)*))[ \t]*([A-Za-z0-9_$]+)[ \t]*=[ \t]*[0-9]+/\5/,number/
--regex-js=/(,|(;|^)[ \t]*(var|let|([A-Za-z_$][A-Za-z0-9_$.]+\.)*))[ \t]*([A-Za-z0-9_$]+)[ \t]*=[ \t]*.+([,;=]|$)/\5/,variable/
--regex-js=/(,|(;|^)[ \t]*(var|let|([A-Za-z_$][A-Za-z0-9_$.]+\.)*))[ \t]*([A-Za-z0-9_$]+)[ \t]*[ \t]*([,;]|$)/\5/,variable/
--regex-js=/function[ \t]+([A-Za-z0-9_$]+)[ \t]*\([^)]*\)/\1/,function/
--regex-js=/(,|^)[ \t]*([A-Za-z_$][A-Za-z0-9_$]+)[ \t]*:[ \t]*\{/\2/,object/
--regex-js=/(,|^)[ \t]*([A-Za-z_$][A-Za-z0-9_$]+)[ \t]*:[ \t]*function[ \t]*\(/\2/,function/
--regex-js=/(,|^)[ \t]*([A-Za-z_$][A-Za-z0-9_$]+)[ \t]*:[ \t]*\[/\2/,array/
--regex-js=/(,|^)[ \t]*([A-Za-z_$][A-Za-z0-9_$]+)[ \t]*:[ \t]*[^"]'[^']*/\2/,string/
--regex-js=/(,|^)[ \t]*([A-Za-z_$][A-Za-z0-9_$]+)[ \t]*:[ \t]*(true|false)/\2/,boolean/
--regex-js=/(,|^)[ \t]*([A-Za-z_$][A-Za-z0-9_$]+)[ \t]*:[ \t]*[0-9]+/\2/,number/
--regex-js=/(,|^)[ \t]*([A-Za-z_$][A-Za-z0-9_$]+)[ \t]*:[ \t]*[^=]+([,;]|$)/\2/,variable/
&lt;/code&gt;&lt;/pre&gt;



&lt;p&gt;
The key point of this setup is the regular expression for HTML should be &lt;b&gt;as simple as possible&lt;/b&gt;!
&lt;/p&gt;
&lt;p&gt;
On Mac, location of ".ctags":
&lt;/p&gt;



&lt;pre&gt;&lt;code class="lang-bash"&gt;/Users/yourname/.ctags
&lt;/code&gt;&lt;/pre&gt;



&lt;p&gt;
On Linux, location of ".ctags":
&lt;/p&gt;



&lt;pre&gt;&lt;code class="lang-bash"&gt;/home/yourname/.ctags
&lt;/code&gt;&lt;/pre&gt;



&lt;p&gt;
On Windows, place ".ctags" anywhere. Then &lt;a href="http://support.microsoft.com/en-us/kb/310519"&gt;create an environment variable&lt;/a&gt; named "HOME" whose value is the parent directory of ".ctags".
&lt;/p&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;/div&gt;

&lt;div id="outline-container-3" class="outline-3"&gt;
&lt;h4 id="sec-3"&gt;&lt;a href="http://www.sublimetext.com/"&gt;Sublime Text&lt;/a&gt;&lt;/h4&gt;
&lt;div class="outline-text-3" id="text-3"&gt;

&lt;p&gt;Install &lt;a href="https://github.com/SublimeText/CTags"&gt;CTags plugin&lt;/a&gt; and follow its instruction.
&lt;/p&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;div id="outline-container-4" class="outline-3"&gt;
&lt;h4 id="sec-4"&gt;&lt;a href="https://www.gnu.org/software/emacs/"&gt;Emacs&lt;/a&gt;&lt;/h4&gt;
&lt;div class="outline-text-3" id="text-4"&gt;

&lt;p&gt;Run CTags at least once:
&lt;/p&gt;



&lt;pre&gt;&lt;code class="lang-bash"&gt;ctags -e -R -f /app/path/TAGS
&lt;/code&gt;&lt;/pre&gt;



&lt;p&gt;
Then insert below code into your ~/.emacs:
&lt;/p&gt;



&lt;pre&gt;&lt;code class="lang-lisp"&gt;(setq tags-table-list '("/app/path/TAGS"))
&lt;/code&gt;&lt;/pre&gt;



&lt;p&gt;
Open Emacs and `M-x find-tag` to start code navigation. That's all.
&lt;/p&gt;
&lt;p&gt;
If you prefer &lt;a href="https://github.com/emacs-helm/helm"&gt;Helm&lt;/a&gt; UI, install it and `M-x helm-etags-select` instead.
&lt;/p&gt;
&lt;p&gt;
Please install the latest helm because I &lt;a href="https://github.com/emacs-helm/helm/pull/965"&gt;enhanced helm-etags-select&lt;/a&gt; for this problem.
&lt;/p&gt;&lt;/div&gt;

&lt;/div&gt;&lt;/div&gt;</description><category>ctags</category><category>emacs</category><category>en</category><category>javascript</category><guid>http://blog.binchen.org/posts/effective-code-navigation-for-web-development.html</guid><pubDate>Thu, 02 Apr 2015 12:51:21 GMT</pubDate></item><item><title>Autocomplete with a dictionary and hippie-expand</title><link>http://blog.binchen.org/posts/autocomplete-with-a-dictionary-with-hippie-expand.html</link><dc:creator>Chen Bin</dc:creator><description>&lt;div&gt;&lt;p&gt;I use &lt;a href="http://company-mode.github.io/"&gt;company-mode&lt;/a&gt; most of the time. Sometimes I use &lt;a href="http://emacswiki.org/emacs/HippieExpand"&gt;Hippie Expand&lt;/a&gt; to autocomplete the English words from a dictionary.
&lt;/p&gt;

&lt;p&gt;
I surely can do this in company-mode too. But I prefer hippie-expand because I choose to make company-mode focus on programming stuff and hippie-expand on writing.
&lt;/p&gt;

&lt;div id="outline-container-1" class="outline-3"&gt;
&lt;h4 id="sec-1"&gt;Solution&lt;/h4&gt;
&lt;div class="outline-text-3" id="text-1"&gt;

&lt;p&gt;This solution works &lt;b&gt;in any environment&lt;/b&gt;.
&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Step1 (OPTIONAL), download &lt;a href="https://github.com/redguardtoo/emacs.d/raw/master/misc/english-words.txt"&gt;english-words.txt&lt;/a&gt; and place it under "~/.emacs.d/misc/".

&lt;/li&gt;
&lt;li&gt;Step 2, Copy below setup into ~/.emacs and use key binding "M-/" to complete the word:
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;&lt;code class="lang-lisp"&gt;(global-set-key (kbd "M-/") 'hippie-expand)

;; The actual expansion function
(defun try-expand-by-dict (old)
  ;; old is true if we have already attempted an expansion
  (unless (bound-and-true-p ispell-minor-mode)
    (ispell-minor-mode 1))

  ;; english-words.txt is the fallback dicitonary
  (if (not ispell-alternate-dictionary)
      (setq ispell-alternate-dictionary (file-truename "~/.emacs.d/misc/english-words.txt")))
  (let ((lookup-func (if (fboundp 'ispell-lookup-words)
                       'ispell-lookup-words
                       'lookup-words)))
    (unless old
      (he-init-string (he-lisp-symbol-beg) (point))
      (if (not (he-string-member he-search-string he-tried-table))
        (setq he-tried-table (cons he-search-string he-tried-table)))
      (setq he-expand-list
            (and (not (equal he-search-string ""))
                 (funcall lookup-func (concat (buffer-substring-no-properties (he-lisp-symbol-beg) (point)) "*")))))
    (if (null he-expand-list)
      (if old (he-reset-string))
      (he-substitute-string (car he-expand-list))
      (setq he-expand-list (cdr he-expand-list))
      t)
    ))

(setq hippie-expand-try-functions-list
      '(;; try-expand-dabbrev
        ;; try-expand-dabbrev-all-buffers
        try-expand-by-dict))
&lt;/code&gt;&lt;/pre&gt;


&lt;/div&gt;

&lt;/div&gt;

&lt;div id="outline-container-2" class="outline-3"&gt;
&lt;h4 id="sec-2"&gt;Technical details&lt;/h4&gt;
&lt;div class="outline-text-3" id="text-2"&gt;

&lt;ul&gt;&lt;li&gt;based on &lt;a href="https://github.com/syohex/emacs-ac-ispell"&gt;ac-ispell&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;lazy load of ispell-mode to speed Emacs startup
&lt;/li&gt;
&lt;li&gt;add a fallback dictionary "english-words.txt" so autocompletion never fails
&lt;/li&gt;
&lt;li&gt;`ispell-lookup-words` or `lookup-words` simply does grep thing, so english-words.txt is just a plain text file.
&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;

&lt;/div&gt;&lt;/div&gt;</description><category>autocomplete</category><category>dictionary</category><category>emacs</category><category>en</category><guid>http://blog.binchen.org/posts/autocomplete-with-a-dictionary-with-hippie-expand.html</guid><pubDate>Mon, 30 Mar 2015 03:53:40 GMT</pubDate></item><item><title>Why people say "Emacs is the best operating system"</title><link>http://blog.binchen.org/posts/why-people-say-emacs-is-the-best-operating-system.html</link><dc:creator>Chen Bin</dc:creator><description>&lt;div&gt;&lt;p&gt;It's becasue Emacs has great documentation and enough APIs.
&lt;/p&gt;

&lt;div id="outline-container-1" class="outline-3"&gt;
&lt;h4 id="sec-1"&gt;Documentation&lt;/h4&gt;
&lt;div class="outline-text-3" id="text-1"&gt;

&lt;p&gt;Its quality is the best.
&lt;/p&gt;
&lt;p&gt;
It helps me even on non-Emacs stuff.
&lt;/p&gt;
&lt;p&gt;
When configuring the font for &lt;a href="http://gnometerminator.blogspot.com/p/introduction.html"&gt;Terminator&lt;/a&gt; (a terminal emulator) I found its manual is NOT clear. The manual didn't explain what is "Pango font name". After googling, I found the Emacs manual which explained it and also provided related toolchain.
&lt;/p&gt;
&lt;p&gt;
For example, "fc-list" is mentioned to list the installed fonts. Since terminal use Mono font, I can type below command:
&lt;/p&gt;



&lt;pre&gt;&lt;code class="lang-bash"&gt;fc-list | grep Mono
&lt;/code&gt;&lt;/pre&gt;



&lt;p&gt;
The output is like:
&lt;/p&gt;



&lt;pre class="example"&gt;/usr/share/fonts/urw-fonts/n022003l.pfb: Nimbus Mono L:style=Regular
/usr/share/fonts/urw-fonts/n022024l.pfb: Nimbus Mono L:style=Bold Oblique
/usr/share/fonts/liberation-fonts/LiberationMono-Regular.ttf: Liberation Mono:style=Regular
/usr/share/fonts/urw-fonts/n022004l.pfb: Nimbus Mono L:style=Bold
/usr/share/fonts/liberation-fonts/LiberationMono-BoldItalic.ttf: Liberation Mono:style=Bold Italic
/usr/share/fonts/liberation-fonts/LiberationMono-Bold.ttf: Liberation Mono:style=Bold
/usr/share/fonts/wqy-zenhei/wqy-zenhei.ttc: 文泉驿等宽正黑,文泉驛等寬正黑,WenQuanYi Zen Hei Mono:style=Medium,中等
/usr/share/fonts/liberation-fonts/LiberationMono-Italic.ttf: Liberation Mono:style=Italic
/usr/share/fonts/urw-fonts/n022023l.pfb: Nimbus Mono L:style=Regular Oblique
&lt;/pre&gt;


&lt;p&gt;
Since Emacs manual explains the meaning of output, I know the font name "WenQuanYi Zen Hei Mono" is the key component of "Pango font name"
&lt;/p&gt;
&lt;p&gt;
Because the manual also gives the details of other components of "Pango font name", the final "~/.config/terminator/config" is like:
&lt;/p&gt;




&lt;pre&gt;&lt;code class="lang-conf"&gt;[profiles]
  [[default]]
  use_system_font = False
  # @see emacs manual for tools and explanation of font formats
  # https://www.gnu.org/software/emacs/manual/html_node/emacs/GTK-Resource-Basics.html
  # https://www.gnu.org/software/emacs/manual/html_node/emacs/Fonts.html#Fonts
  font =  WenQuanYi Zen Hei Mono 16
&lt;/code&gt;&lt;/pre&gt;


&lt;/div&gt;

&lt;/div&gt;

&lt;div id="outline-container-2" class="outline-3"&gt;
&lt;h4 id="sec-2"&gt;API&lt;/h4&gt;
&lt;div class="outline-text-3" id="text-2"&gt;

&lt;p&gt;I create a new Emacs plugin which lists file names containing Chinese characters. At beginning I use Emacs API "find-name-dired". It uses the GNU find as the backend. But there is some integration issue on Linux. Chinese file names are displayed as garbled text in Emacs. I guess there is some decode/encode error between the interaction of Emacs process and GNU find process because Chinese files are fine on OS X.
&lt;/p&gt;
&lt;p&gt;
Emacs has enough APIs. Later I found another pure Lisp API "find-lisp-find-dired". Problem solved.
&lt;/p&gt;&lt;/div&gt;

&lt;/div&gt;&lt;/div&gt;</description><category>emacs</category><category>en</category><category>font</category><category>linux</category><category>terminal</category><category>terminator</category><guid>http://blog.binchen.org/posts/why-people-say-emacs-is-the-best-operating-system.html</guid><pubDate>Sun, 01 Feb 2015 09:40:44 GMT</pubDate></item></channel></rss>