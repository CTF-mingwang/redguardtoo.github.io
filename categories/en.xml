<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/"><channel><title>Chen's blog (Posts about en)</title><link>http://blog.binchen.org/</link><description></description><atom:link href="http://blog.binchen.org/categories/en.xml" type="application/rss+xml" rel="self"></atom:link><language>en</language><lastBuildDate>Sun, 17 Jun 2018 03:34:02 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>How to spell check function/variable in Emacs</title><link>http://blog.binchen.org/posts/how-to-spell-check-functionvariable-in-emacs.html</link><dc:creator>Chen Bin</dc:creator><description>&lt;div id="outline-container-orge63cb3a" class="outline-2"&gt;
&lt;h3 id="orge63cb3a"&gt;&lt;span class="section-number-2"&gt;1&lt;/span&gt; How to spell check function/variable in Emacs   &lt;span class="tag"&gt;&lt;span class="en"&gt;en&lt;/span&gt; &lt;span class="emacs"&gt;emacs&lt;/span&gt; &lt;span class="flyspell"&gt;flyspell&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;p&gt;
&lt;a href="http://blog.binchen.org/posts/effective-spell-check-in-emacs.html"&gt;This article&lt;/a&gt; explains how developers can check typos of function/variable while programming in Emacs.
&lt;/p&gt;

&lt;p&gt;
It uses the &lt;code&gt;--run-together&lt;/code&gt; option of &lt;a href="http://aspell.net/"&gt;GNU Aspell&lt;/a&gt; to check camel cased word.
&lt;/p&gt;

&lt;p&gt;
But this solution is not perfect. It wrongly labels two character interior word as typo. For example, since "on" from "onChange" is typo, the whole word "onChange" becomes typo. Another issue is namespace of function name. For example, "MS" from "MSToggleButton" is alias of "Microsoft". "MS" should be excluded from check.
&lt;/p&gt;

&lt;p&gt;
In this article, I will explain how Emacs spell checker works at first. Then we study the algorithm of aspell. Finally, I will give you a complete setup to solve all issues we mentioned at the end of this article.
&lt;/p&gt;

&lt;p&gt;
In Emacs, a built in plugin &lt;a href="https://www.emacswiki.org/emacs/FlySpell"&gt;Fly Spell&lt;/a&gt; is in charge of spell check. It passes the options and text to process to command line tool aspell. Aspell checks the text and pass the list of typos back into &lt;code&gt;Fly Spell&lt;/code&gt;. &lt;code&gt;Fly Spell&lt;/code&gt; then picks up the final list of typos to be displayed. For example, if &lt;code&gt;flyspell-prog-mode&lt;/code&gt; is on, only typos in comments and strings are reported.
&lt;/p&gt;

&lt;p&gt;
So aspell doesn't understand syntax of any programming language. It scans plain text and report all typos to Fly Spell.
&lt;/p&gt;

&lt;p&gt;
In aspell, there are two extra "run-together" word options:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;code&gt;--run-together-limit&lt;/code&gt; is "Maximum number of words can be strung together"&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--run-together-min&lt;/code&gt; is "Minimal length of interior words"&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
Let's study the code of aspell to understand the meaning of these two options. The "run-together" algorithm in implemented in function &lt;code&gt;Working::check_word&lt;/code&gt; of file "modules/speller/default/suggest.cpp". I documented the code line by line.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre&gt;&lt;code class="lang-c"&gt;class Working : public Score {
  unsigned check_word(char * word, char * word_end, CheckInfo * ci, unsigned pos = 1);
};
unsigned Working::check_word(char * word, char * word_end,  CheckInfo * ci,
                             /* it WILL modify word */
                             unsigned pos)
{
  // check the whole word before go into run-together mode
  unsigned res = check_word_s(word, ci);
  // if `res` is true, it's a valid word, don't bother run-together
  if (res) return pos + 1;
  // it's typo because number of interior words is greater than "--run-together-limit"
  if (pos + 1 &amp;gt;= sp-&amp;gt;run_together_limit_) return 0;

  // `i` is the `end` of interior word, the poition AFTER last character of interior word
  for (char * i = word + sp-&amp;gt;run_together_min_; 
       // we already checked the word; besides, any interior word whose length is less 
       // than "--run-together-min" is regarded as invalid word
       i &amp;lt;= word_end - sp-&amp;gt;run_together_min_;
       ++i)
  {
    char t = *i;
    *i = '\0'; // read the interior word by set the character at `end` position to '\0'
    res = check_word_s(word, ci);
    *i = t; // restore original character at `end` position
    // Well, current interior word is invalid, we need include append the character at current
    //  `end` position into this it to create a new interior word. Also increment `end` position.
    if (!res) continue;
    // OK, current interior word is valid, we strip it from the whole word to create a totally
    // new word for `check_word`, `check_word` is a recursive function
    res = check_word(i, word_end, ci + 1, pos + 1);
    if (res) return res;
  }
  memset(ci, 0, sizeof(CheckInfo));
  return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;
Let's use "hisHelle" as demo how &lt;code&gt;check_word&lt;/code&gt; runs:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;"word" points to string array "hisHelle"&lt;/li&gt;
&lt;li&gt;"sp-&amp;gt;run_together_min_" is 3, so "i" initially points to the character "H", at the end of interior word "his"&lt;/li&gt;
&lt;li&gt;"check_word_s" return "true" for interior word "his"&lt;/li&gt;
&lt;li&gt;So we strip "his" from "hisHelle" and recursively call "check_word" to check new word "Helle"&lt;/li&gt;
&lt;li&gt;In the new context of "check_word", we extract "Hel" from "Helle" initially&lt;/li&gt;
&lt;li&gt;"Hel" is invalid. So we extract "Hell" from "Helle" and get new word "e" and recursively apply "check_word" on "e".&lt;/li&gt;
&lt;li&gt;"e" is not valid and at the end of rescursion. So "hisHelle" is a typo.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
Here is our conclusion after studying the code:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;code&gt;--run-together-limit&lt;/code&gt; could not be bigger if your computer got enough memory. It's default value is 8. I prefer 16.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--run-together-min&lt;/code&gt; can't be 2 because too many typos are combination of "correct" two character interior words ("hehe", "isme", …)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--run-together-min&lt;/code&gt; can't be greater than 3, or else, too many "correct" three character interior words are regarded as invalid ("his", "her", "one", "two")&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--run-together-min&lt;/code&gt; should always be 3 which is its default value. Actually, it should never be tweakable by user at the beginning&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
Since &lt;code&gt;--run-together-min&lt;/code&gt; is 3. the word "onChange" is always regarded as typo because of two character interior word "on". Since there is nothing we can do at aspell side, we have to turn to Emacs to fix this problem.
&lt;/p&gt;

&lt;p&gt;
When Emacs got potential typo on Emacs side, we can strip out all the two character interior word from orginal word and spell check new word again.
&lt;/p&gt;

&lt;p&gt;
We can attach a predicate into specific major-mode. The predicate return &lt;code&gt;t&lt;/code&gt; if current word at cursor is typo,
&lt;/p&gt;
&lt;div class="org-src-container"&gt;

&lt;pre&gt;&lt;code class="lang-lisp"&gt;(defun js-flyspell-verify ()
  (let* ((font-face (get-text-property (- (point) 1) 'face))
         (word (thing-at-point 'word)))
    (message "font-face=%s word=%s" font-face word)
    t))
(put 'js2-mode 'flyspell-mode-predicate 'js-flyspell-verify)
&lt;/code&gt;&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;
As you can see from above code, we have full control on what typos should be displayed in &lt;code&gt;js-flyspell-verify&lt;/code&gt;. So namespace is also easy problem. If namespace is three characters, it will be automatically processed by aspell. All we need to do is add namespace into our personal dictionary &lt;code&gt;$HOME/.aspell.en.pws&lt;/code&gt;. If namespace is one or two characters, we strip down it from original word. Same way as we deal with two character interior word.
&lt;/p&gt;

&lt;p&gt;
Here is complete setup you can paste into &lt;code&gt;.emacs&lt;/code&gt; (I setup for &lt;code&gt;js2-mode&lt;/code&gt; and &lt;code&gt;rjsx-mode&lt;/code&gt; but code is generic enough),
&lt;/p&gt;
&lt;div class="org-src-container"&gt;

&lt;pre&gt;&lt;code class="lang-lisp"&gt;(setq ispell-program-name "aspell")
(defun flyspell-detect-ispell-args (&amp;amp;optional run-together)
  "If RUN-TOGETHER is true, spell check the CamelCase words.
Please note RUN-TOGETHER will make aspell less capable. So it should only be used in prog-mode-hook."
  ;; force the English dictionary, support Camel Case spelling check (tested with aspell 0.6)
  (let* ((args (list "--sug-mode=ultra" "--lang=en_US"))args)
    (if run-together
        (setq args (append args '("--run-together" "--run-together-limit=16"))))
    args))

(defvar extra-flyspell-predicate '(lambda (word) t)
  "A callback to check WORD.  Return t if WORD is typo.")

(defun my-flyspell-predicate (word)
  "Use aspell to check WORD.  If it's typo return true."
  (if (string-match-p (concat "^&amp;amp; " word)
                      (shell-command-to-string (format "echo %s | %s %s pipe"
                                                       word
                                                       ispell-program-name
                                                       (mapconcat 'identity
                                                                  (flyspell-detect-ispell-args t)
                                                                  " "))))
      t))

(defmacro my-flyspell-predicate-factory (preffix)
  `(lambda (word)
     (let* ((pattern (concat "^\\(" ,preffix "\\)\\([A-Z]\\)"))
            rlt)
       (cond
        ((string-match-p pattern word)
         (setq word (replace-regexp-in-string pattern "\\2" word))
         (setq rlt (my-flyspell-predicate word)))
        (t
         (setq rlt t)))
       rlt)))

(defun js-flyspell-verify ()
  (let* ((case-fold-search nil)
         (font-matched (memq (get-text-property (- (point) 1) 'face)
                             '(js2-function-call
                               js2-function-param
                               js2-object-property
                               font-lock-variable-name-face
                               font-lock-string-face
                               font-lock-function-name-face
                               font-lock-builtin-face
                               rjsx-tag
                               rjsx-attr)))
         word
         (rlt t))
    (cond
     ((not font-matched)
      (setq rlt nil))
     ((not (string-match-p "aspell$" ispell-program-name))
      ;; Only override aspell's result
      (setq rlt t))
     ((string-match-p "^[a-zA-Z][a-zA-Z]$"
                      (setq word (thing-at-point 'word)))
      (setq rlt nil))
     ((string-match-p "\\([A-Z][a-z]\\|^[a-z][a-z]\\)[A-Z]\\|[a-z][A-Z][a-z]$"
                      word)
      ;; strip two character interior words
      (setq word (replace-regexp-in-string "\\([A-Z][a-z]\\|^[a-z][a-z]\\)\\([A-Z]\\)" "\\2" word))
      (setq word (replace-regexp-in-string "\\([a-z]\\)[A-Z][a-z]$" "\\1" word))
      ;; check stripped word
      (setq rlt (my-flyspell-predicate word)))
     (t
      (setq rlt (funcall extra-flyspell-predicate word))))
    rlt))
(put 'js2-mode 'flyspell-mode-predicate 'js-flyspell-verify)
(put 'rjsx-mode 'flyspell-mode-predicate 'js-flyspell-verify)

(defun prog-mode-hook-setup ()
  ;; remove namespace "MS" and "X"
  (setq-local extra-flyspell-predicate (my-flyspell-predicate-factory "MS\\|X")))
(add-hook 'prog-mode-hook 'prog-mode-hook-setup)
&lt;/code&gt;&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;
Optionally, you could see &lt;a href="https://github.com/redguardtoo/emacs.d/blob/master/lisp/init-spelling.el"&gt;https://github.com/redguardtoo/emacs.d/blob/master/lisp/init-spelling.el&lt;/a&gt; for my real world setup.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>emacs</category><category>en</category><category>flyspell</category><guid>http://blog.binchen.org/posts/how-to-spell-check-functionvariable-in-emacs.html</guid><pubDate>Sun, 17 Jun 2018 03:16:41 GMT</pubDate></item><item><title>Use Imenu to list comments in current buffer</title><link>http://blog.binchen.org/posts/use-imenu-to-list-comments-in-current-buffer.html</link><dc:creator>Chen Bin</dc:creator><description>&lt;div id="outline-container-sec-1" class="outline-2"&gt;

&lt;div class="outline-text-2" id="text-1"&gt;
&lt;p&gt;
&lt;a href="https://github.com/redguardtoo/evil-nerd-commenter"&gt;evil-nerd-commenter&lt;/a&gt; v3.2.0 has a new function &lt;code&gt;evilnc-imenu-create-index-function&lt;/code&gt;.
&lt;/p&gt;

&lt;p&gt;
&lt;a href="http://www.gnu.org/s/emacs/manual/html_node/emacs/Imenu.html"&gt;Imenu&lt;/a&gt; could use this function to list all comments in current file.
&lt;/p&gt;

&lt;p&gt;
Usage:
&lt;/p&gt;
&lt;div class="org-src-container"&gt;


&lt;pre&gt;&lt;code class="lang-lisp"&gt;(require 'counsel)
(defun counsel-imenu-comments ()
  "Imenu display comments."
  (interactive)
  (let* ((imenu-create-index-function 'evilnc-imenu-create-index-function))
    (counsel-imenu)))
&lt;/code&gt;&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;
Screen cast:
&lt;/p&gt;


&lt;div class="figure"&gt;
&lt;p&gt;&lt;img src="http://blog.binchen.org/wp-content/counsel-imenu-comments.gif" alt="counsel-imenu-comments.gif"&gt;
&lt;/p&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>emacs</category><category>en</category><category>imenu</category><guid>http://blog.binchen.org/posts/use-imenu-to-list-comments-in-current-buffer.html</guid><pubDate>Sun, 08 Apr 2018 02:12:04 GMT</pubDate></item><item><title>counsel-etags v1.3.1 is released</title><link>http://blog.binchen.org/posts/counsel-etags-v1-3-1-is-released-enemacsctags.html</link><dc:creator>Chen Bin</dc:creator><description>&lt;div id="outline-container-sec-1" class="outline-2"&gt;

&lt;div class="outline-text-2" id="text-1"&gt;
&lt;p&gt;
&lt;a href="https://github.com/redguardtoo/counsel-etags"&gt;Counsel-etags&lt;/a&gt; is a generic solution for code navigation in Emacs.
&lt;/p&gt;

&lt;p&gt;
It basically needs no setup. For example, one command &lt;code&gt;counsel-etags-find-tag-at-point&lt;/code&gt; is enough to start code navigation immediately.
&lt;/p&gt;

&lt;p&gt;
The package solves all the problems using Ctags/Etags with Emacs.
&lt;/p&gt;

&lt;p&gt;
&lt;b&gt;Problem 1:&lt;/b&gt; Ctags takes a few seconds to update the tags file (the index file to lookup tags). The updating process blocks the user's further interaction. This problem is solved by the virtual updating function from &lt;code&gt;counsel-etags&lt;/code&gt;. The setup is simple:
&lt;/p&gt;
&lt;div class="org-src-container"&gt;


&lt;pre&gt;&lt;code class="lang-lisp"&gt;;; Don't ask before rereading the TAGS files if they have changed
(setq tags-revert-without-query t)
;; Don't warn when TAGS files are large
(setq large-file-warning-threshold nil)
;; Setup auto update now
(add-hook 'prog-mode-hook
  (lambda ()
    (add-hook 'after-save-hook
              'counsel-etags-virtual-update-tags 'append 'local)))
(add-hook 'after-save-hook 'counsel-etags-virtual-update-tags)
&lt;/code&gt;&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;
&lt;b&gt;Problem 2:&lt;/b&gt; Tag lookup may fail if the latest code is not scanned yet. This problem is solved by running &lt;code&gt;counsel-etags-grep&lt;/code&gt; &lt;b&gt;automatically&lt;/b&gt; if &lt;code&gt;counsel-etags-find-tag-at-point&lt;/code&gt; fails. So users always get results.
&lt;/p&gt;

&lt;p&gt;
There are also other enhancements.
&lt;/p&gt;

&lt;p&gt;
&lt;b&gt;Enhancement 1:&lt;/b&gt; Levenshtein Distance algorithm is used to place the better matching candidates at the the top. For example, a function named &lt;code&gt;renderTable&lt;/code&gt; could be defined all around in a ReactJS project. But it's very possible the user prefers the definition in same component or same folder where she triggers code navigation.
&lt;/p&gt;

&lt;p&gt;
&lt;b&gt;Enhancement 2:&lt;/b&gt; It's inefficient to search the same tag again and again. &lt;code&gt;counsel-etags-recent-tag&lt;/code&gt; is used to jump to previous definitions.
&lt;/p&gt;

&lt;p&gt;
&lt;b&gt;Enhancement 3:&lt;/b&gt; &lt;a href="https://github.com/abo-abo/swiper"&gt;Ivy-mode&lt;/a&gt; provides filter UI for &lt;code&gt;counsel-etags&lt;/code&gt;. Its means all the functionalities from Ivy is also available. For example, users can input "!keyword1" to &lt;b&gt;exclude&lt;/b&gt; candidates matching "keyword1".
&lt;/p&gt;

&lt;p&gt;
&lt;b&gt;Enhancement 4:&lt;/b&gt; &lt;code&gt;counsel-etags-grep&lt;/code&gt; uses the fastest grep program &lt;a href="https://github.com/BurntSushi/ripgrep"&gt;ripgrep&lt;/a&gt; if it's installed. Or else it falls back to standard grep.
&lt;/p&gt;

&lt;p&gt;
Please check &lt;a href="https://github.com/redguardtoo/counsel-etags"&gt;https://github.com/redguardtoo/counsel-etags&lt;/a&gt; for more tips.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>emacs</category><category>en</category><category>etags</category><guid>http://blog.binchen.org/posts/counsel-etags-v1-3-1-is-released-enemacsctags.html</guid><pubDate>Sun, 12 Nov 2017 09:40:15 GMT</pubDate></item><item><title>Auto complete everything in Emacs</title><link>http://blog.binchen.org/posts/auto-complete-everything-in-emacs.html</link><dc:creator>Chen Bin</dc:creator><description>&lt;div&gt;&lt;p&gt;
complete everything in Emacs                                             :en:emacs:
&lt;/p&gt;

&lt;p&gt;
As a web developer using modern front end framework like React/Angular, I spend a lot of time on web components. 
&lt;/p&gt;

&lt;p&gt;
A component instance is like:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre&gt;&lt;code class="lang-javascript"&gt;&amp;lt;GenericTable
  onSelectRow={ row =&amp;gt; console.log(row) }
  numberOfPinnedColumns={2}
  withToolBar
  onClickCell={ cell =&amp;gt; console.log(cell) }
&amp;gt;
  &amp;lt;PaginationButtons /&amp;gt;
  &amp;lt;TotalSum /&amp;gt;
  &amp;lt;ReportButtons /&amp;gt;
&amp;lt;/GenericTable&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;
Basically a component instance is a big chunk of html tags.
&lt;/p&gt;

&lt;p&gt;
I created a new package &lt;a href="https://github.com/redguardtoo/eacl"&gt;EACL&lt;/a&gt; (Emacs auto complete lines) which could help me &lt;b&gt;input components in unbelievable speed&lt;/b&gt;.
&lt;/p&gt;

&lt;p&gt;
The idea is simple. If I've already used one component elsewhere in the project. It's unnecessary to re-type the similar code again.
&lt;/p&gt;

&lt;p&gt;
All I need to do is to input the first characters of the component and run &lt;code&gt;M-x eacl-complete-tag&lt;/code&gt; which will grep the project and input the remaining part of component.
&lt;/p&gt;

&lt;p&gt;
Here is a demo to input component &lt;code&gt;ButtonToolbar&lt;/code&gt;:
&lt;/p&gt;

&lt;div class="figure"&gt;
&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/redguardtoo/eacl/master/eacl-demo.gif" alt="eacl-demo.gif"&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;
Please note &lt;code&gt;EACL&lt;/code&gt; is generic and can be use in any programming language. 
&lt;/p&gt;

&lt;p&gt;
&lt;code&gt;M-x eacl-complete-statement&lt;/code&gt; to &lt;b&gt;complete below Javascript code&lt;/b&gt;:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre&gt;&lt;code class="lang-javascript"&gt;import {
  Button,
  Row,
  Column
} from 'react-bootstrap';
&lt;/code&gt;&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;
&lt;code&gt;M-x eacl-complete-snippet&lt;/code&gt; to &lt;b&gt;complete below C code&lt;/b&gt;:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre&gt;&lt;code class="lang-c"&gt;static int v9fs_drop_inode(struct inode *inode)
{
    struct v9fs_session_info *v9ses;
    v9ses = v9fs_inode2v9ses(inode);
    if (v9ses-&amp;gt;cache == CACHE_LOOSE || v9ses-&amp;gt;cache == CACHE_FSCACHE)
        return generic_drop_inode(inode);
    /*
     * in case of non cached mode always drop the
     * the inode because we want the inode attribute
     * to always match that on the server.
     */
    return 1;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;
You can also create your own commands based on API &lt;code&gt;eacl-complete-multi-lines-internal&lt;/code&gt;.
&lt;/p&gt;

&lt;p&gt;
For example, it is a piece of cake to support Lisp by creating comand &lt;code&gt;my-complete-lisp&lt;/code&gt;:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre&gt;&lt;code class="lang-lisp"&gt;(require 'eacl)
(defun my-complete-lisp ()
  (interactive)
  (eacl-complete-multi-lines-internal "[^)]*)"))
&lt;/code&gt;&lt;/pre&gt;

&lt;/div&gt;&lt;/div&gt;</description><category>emacs</category><category>en</category><guid>http://blog.binchen.org/posts/auto-complete-everything-in-emacs.html</guid><pubDate>Mon, 30 Oct 2017 11:13:30 GMT</pubDate></item><item><title>Split Emacs window with certain ratio</title><link>http://blog.binchen.org/posts/split-emacs-window-with-certain-ratio.html</link><dc:creator>Chen Bin</dc:creator><description>&lt;div&gt;&lt;p&gt;
Emacs window with certain ratio                                        :en:emacs:
&lt;/p&gt;

&lt;p&gt;
The idea comes from &lt;a href="https://github.com/redguardtoo/emacs.d/issues/607"&gt;yangdaweihit&lt;/a&gt;. Here is the implementation.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre&gt;&lt;code class="lang-lisp"&gt;(defvar my-ratio-dict
  '((1 . 1.61803398875)
    (2 . 2)
    (3 . 3)
    (4 . 4)
    (5 . 0.61803398875))
  "The ratio dictionary.")

(defun my-split-window-horizontally (&amp;amp;optional ratio)
  "Split window horizontally and resize the new window.
Always focus bigger window."
  (interactive "P")
  (let* (ratio-val)
    (cond
     (ratio
      (setq ratio-val (cdr (assoc ratio my-ratio-dict)))
      (split-window-horizontally (floor (/ (window-body-width)
                                           (1+ ratio-val)))))
     (t
      (split-window-horizontally)))
    (set-window-buffer (next-window) (other-buffer))
    (if (or (not ratio-val)
            (&amp;gt;= ratio-val 1))
        (windmove-right))))

(defun my-split-window-vertically (&amp;amp;optional ratio)
  "Split window vertically and resize the new window.
Always focus bigger window."
  (interactive "P")
  (let* (ratio-val)
    (cond
     (ratio
      (setq ratio-val (cdr (assoc ratio my-ratio-dict)))
      (split-window-vertically (floor (/ (window-body-height)
                                         (1+ ratio-val)))))
     (t
      (split-window-vertically)))
    ;; open another window with other-buffer
    (set-window-buffer (next-window) (other-buffer))
    ;; move focus if new window bigger than current one
    (if (or (not ratio-val)
            (&amp;gt;= ratio-val 1))
        (windmove-down))))

(global-set-key (kbd "C-x 2") 'my-split-window-vertically)
(global-set-key (kbd "C-x 3") 'my-split-window-horizontally)
&lt;/code&gt;&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;
Usage is simple. For example, &lt;code&gt;C-x 2&lt;/code&gt; is similar to original &lt;code&gt;split-winddow-vertically&lt;/code&gt; while &lt;code&gt;C-u 1 C-x 2&lt;/code&gt; split the window in golden ratio.
&lt;/p&gt;&lt;/div&gt;</description><category>emacs</category><category>en</category><guid>http://blog.binchen.org/posts/split-emacs-window-with-certain-ratio.html</guid><pubDate>Tue, 05 Sep 2017 13:26:55 GMT</pubDate></item><item><title>Enhance diff-mode with Ivy</title><link>http://blog.binchen.org/posts/enhance-diff-mode-with-ivy.html</link><dc:creator>Chen Bin</dc:creator><description>&lt;div&gt;&lt;p&gt;
diff-mode with Ivy                                                    :en:emacs:diff:ivy:
&lt;/p&gt;

&lt;p&gt;
My current job requires me to review the freelancer's patches and apply them to our code branch under &lt;a href="https://www.perforce.com/"&gt;Perforce&lt;/a&gt; control. Due to my client's security policy, the freelancer can only work on isolated sandbox environment and can't access our code base directly.
&lt;/p&gt;

&lt;p&gt;
I need two steps to finish the task:
&lt;/p&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;Open the freelancer's patch in &lt;code&gt;diff-mode&lt;/code&gt;
&lt;/li&gt;
&lt;li&gt;Run &lt;code&gt;diff-apply-hunk&lt;/code&gt; to apply the hunks interactively
&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
The problem is &lt;code&gt;diff-mode&lt;/code&gt; always ask me to specify the file to be patched.
&lt;/p&gt;

&lt;p&gt;
I read the code of &lt;code&gt;diff-apply-hunk&lt;/code&gt;. The logic of &lt;code&gt;diff-apply-hunk&lt;/code&gt; is simple. It tries different algorithms to guess the right file to patch. When the algorithms fail, it calls API &lt;code&gt;read-file-name&lt;/code&gt; to ask me to provide the file path manually. If right file is found, the algorithms will work again and &lt;code&gt;read-file-name&lt;/code&gt; will never be used for other hunks.
&lt;/p&gt;

&lt;p&gt;
Here is my solution. I can find the file to patch in recent opened files because I store all of them by &lt;code&gt;(setq recentf-max-saved-items 2048)&lt;/code&gt;. I plan to use &lt;code&gt;ivy-read&lt;/code&gt; from &lt;a href="https://github.com/abo-abo/swiper"&gt;Ivy&lt;/a&gt; to locate the file at first. If this step fails , I can still fall back on original API &lt;code&gt;read-file-name&lt;/code&gt;.
&lt;/p&gt;

&lt;p&gt;
Here is the code
&lt;/p&gt;

&lt;pre class="example"&gt;
&lt;/pre&gt;

&lt;div class="org-src-container"&gt;

&lt;pre&gt;&lt;code class="lang-lisp"&gt;(defvar ffip-read-file-name-hijacked-p nil)
(defun ffip-diff-apply-hunk (&amp;amp;optional reverse)
  (interactive "P")
  (unless recentf-mode (recentf-mode 1))
  (setq ffip-read-file-name-hijacked-p t)
  (defadvice read-file-name (around ffip-read-file-name-hack activate)
    (cond
     (ffip-read-file-name-hijacked-p
      (let* ((args (ad-get-args 0))
             (file-name (file-name-nondirectory (nth 2 args)))
             (cands (remove nil (mapcar (lambda (s) (if (string-match-p (format "%s$" file-name) s) s))
                                        (mapcar #'substring-no-properties recentf-list))))
             (rlt (ivy-read "Recentf: " cands)))
        (if rlt (setq ad-return-value rlt) rlt ad-doit)))
     (t
      ad-do-it)))
  (diff-apply-hunk reverse)
  (setq ffip-read-file-name-hijacked-p nil))
&lt;/code&gt;&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;
Please note &lt;code&gt;ffip-diff-apply-hunk&lt;/code&gt; can replace &lt;code&gt;diff-apply-hunk&lt;/code&gt;.
&lt;/p&gt;

&lt;p&gt;
BTW, I can edit the patch on the spot when applying hunks. Similar to the work flow of &lt;code&gt;git add --patch&lt;/code&gt;.
&lt;/p&gt;

&lt;p&gt;
The solution is added into &lt;a href="https://github.com/technomancy/find-file-in-project"&gt;https://github.com/technomancy/find-file-in-project&lt;/a&gt;.&lt;/p&gt;&lt;/div&gt;</description><category>diff</category><category>emacs</category><category>en</category><category>ivy</category><guid>http://blog.binchen.org/posts/enhance-diff-mode-with-ivy.html</guid><pubDate>Tue, 30 May 2017 12:29:12 GMT</pubDate></item><item><title>Firefox and Emacs</title><link>http://blog.binchen.org/posts/firefox-and-emacs.html</link><dc:creator>Chen Bin</dc:creator><description>&lt;div&gt;&lt;p&gt;
and Emacs                                                             :en:emacs:firefox:ivy:keysnail:
&lt;/p&gt;

&lt;p&gt;
For me, there is NO difference between Firefox and Emacs. They provide useful APIs, nothing more.
&lt;/p&gt;

&lt;p&gt;
Three years ago, I wrote &lt;a href="http://blog.binchen.org/posts/use-firefox-in-emacs-way-3.html"&gt;Use firefox in Emacs way&lt;/a&gt; to demo how to convert Firefox into Emacs by &lt;a href="https://github.com/mooz/keysnail/wiki"&gt;Keynsail.&lt;/a&gt;
&lt;/p&gt;

&lt;p&gt;
A year ago I published &lt;a href="http://blog.binchen.org/posts/hello-ivy-mode-bye-helm.html"&gt;Hello Ivy-mode, bye Helm&lt;/a&gt; to prove how powerful &lt;a href="https://github.com/abo-abo/swiper"&gt;Ivy-mode&lt;/a&gt; is by using its API &lt;code&gt;ivy-read&lt;/code&gt;.
&lt;/p&gt;

&lt;p&gt;
Keysnail has similar javascript API &lt;code&gt;prompt.selector&lt;/code&gt; and it's as powerful as &lt;code&gt;ivy-read&lt;/code&gt; if not more powerful.
&lt;/p&gt;

&lt;p&gt;
For example, you can insert below snippet into &lt;code&gt;~/.keysnail.js&lt;/code&gt; and press ",hh" or "C-c C-h" to query browse history:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre&gt;&lt;code class="lang-javascript"&gt;function searchHistory(evt, arg) {
  function timeSince(now, date) {

    var seconds = Math.floor((now - date) / 1000);

    var interval = Math.floor(seconds / 31536000);

    if (interval &amp;gt; 1) {
      return interval + " years";
    }
    interval = Math.floor(seconds / 2592000);
    if (interval &amp;gt; 1) {
      return interval + " months";
    }
    interval = Math.floor(seconds / 86400);
    if (interval &amp;gt; 1) {
      return interval + " days";
    }
    interval = Math.floor(seconds / 3600);
    if (interval &amp;gt; 1) {
      return interval + " hours";
    }
    interval = Math.floor(seconds / 60);
    if (interval &amp;gt; 1) {
      return interval + " minutes";
    }
    return Math.floor(seconds) + " seconds";
  }

  function searchWithKeyword(q) {
    var collection = (function() {
      //search option
      var options = PlacesUtils.history.getNewQueryOptions();
      options.maxResults = 4096;
      options.queryType = Ci.nsINavHistoryQueryOptions.QUERY_TYPE_HISTORY;
      //options.sortingMode = Ci.nsINavHistoryQueryOptions.SORT_BY_FRECENCY_DESCENDING;
      options.sortingMode = Ci.nsINavHistoryQueryOptions.SORT_BY_DATE_DESCENDING;
      options.includeHidden = true;

      //search query
      var query = PlacesUtils.history.getNewQuery();
      // read keyworld
      if(q &amp;amp;&amp;amp; q !== '') {
        query.searchTerms  = q;
      }

      var result = PlacesUtils.history.executeQuery(query, options);
      var root = result.root;

      var collection = [];
      var now = new Date().getTime();
      var siteNode;
      root.containerOpen = true;
      for (var i = 0; i &amp;lt; root.childCount; i++) {
        // siteNode =&amp;gt; nsINavHistoryResultNode
        siteNode = root.getChild(i);
        collection.push([siteNode.icon,siteNode.title,siteNode.uri, siteNode.time/1000]);
      }
      collection.sort(function(a, b) {
        return b[3]-a[3];
      });
      // reformat the time
      for (i = 0; i &amp;lt; collection.length; i++) {
        collection[i][3] = timeSince(now, collection[i][3]) + ' ago';
      }
      root.containerOpen = false;
      return collection;
    })();

    prompt.selector({
      message    : "Search history"+ (q &amp;amp;&amp;amp; q !== ''? (' @'+q +':') : ':' ),
      collection : collection,
      flags      : [ICON | IGNORE, 0, 0, 0],
      header     : ["Title", "Url", "Last visited"],
      width      : [30, 60, 10],
      callback: function (i) {
        if (i &amp;gt;= 0) {
          openUILinkIn(collection[i][2], "tab");
        }
      },
      onFinish: function() {
        gBrowser.focus();
        _content.focus();
      }
    });
  }

  prompt.finish(true);
  prompt.read('Keyword to search history?', searchWithKeyword, null, null, null, 0, "history_search");
  // searchWithKeyword('test');

}
key.setViewKey([',', 'h', 'h'], searchHistory, "Search history");
key.setGlobalKey(['C-c', 'C-h'], searchHistory, "Search history");
&lt;/code&gt;&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;
Here is my complete &lt;a href="https://gist.github.com/redguardtoo/003ac86d4c11b70b870a"&gt;.keysnail.js&lt;/a&gt;.
&lt;/p&gt;&lt;/div&gt;</description><category>emacs</category><category>en</category><category>firefox</category><category>ivy</category><category>keysnail</category><guid>http://blog.binchen.org/posts/firefox-and-emacs.html</guid><pubDate>Tue, 23 May 2017 12:24:25 GMT</pubDate></item><item><title>Use wgrep and evil to replace text efficiently</title><link>http://blog.binchen.org/posts/use-wgrep-and-evil-to-replace-text-efficiently.html</link><dc:creator>Chen Bin</dc:creator><description>&lt;div&gt;&lt;p&gt;
wgrep and evil to replace text efficiently                                :en:emacs:wgrep:
&lt;/p&gt;

&lt;p&gt;
In my previous article &lt;a href="http://blog.binchen.org/posts/emacs-is-easy-if-you-read-code.html"&gt;Emacs is easy if you read code&lt;/a&gt;, I proved ivy and wgrep is easy if you read code. You can even create your own plugin based on their APIs. For example, I define &lt;code&gt;my-grep&lt;/code&gt; and &lt;code&gt;my-grep-occur&lt;/code&gt; in &lt;a href="https://github.com/redguardtoo/emacs.d/blob/deb521f15e530527598572ef50fd66ea2936fc3c/lisp/init-ivy.el"&gt;init-ivy.el&lt;/a&gt; in order to search/replace text in project root directory.
&lt;/p&gt;

&lt;p&gt;
My wgrep-mode enabled buffer is in evil-mode. I prefer pressing vi key binding &lt;code&gt;dd&lt;/code&gt; to remove lines in that buffer to tell wgrep skip them.
&lt;/p&gt;

&lt;p&gt;
It turns out we need &lt;code&gt;M-x C-c C-p&lt;/code&gt; or &lt;code&gt;M-x wgrep-toggle-readonly-area&lt;/code&gt; before removing lines.
&lt;/p&gt;

&lt;p&gt;
I'm too lazy to remember extra commands. So here is the workaround:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre&gt;&lt;code class="lang-lisp"&gt;;; Press `dd' to delete lines in `wgrep-mode' in evil directly
(defadvice evil-delete (around evil-delete-hack activate)
  ;; make buffer writable
  (if (and (boundp 'wgrep-prepared) wgrep-prepared)
      (wgrep-toggle-readonly-area))
  ad-do-it
  ;; make buffer read-only
  (if (and (boundp 'wgrep-prepared) wgrep-prepared)
      (wgrep-toggle-readonly-area)))
&lt;/code&gt;&lt;/pre&gt;

&lt;/div&gt;&lt;/div&gt;</description><category>emacs</category><category>en</category><category>wgrep</category><guid>http://blog.binchen.org/posts/use-wgrep-and-evil-to-replace-text-efficiently.html</guid><pubDate>Mon, 22 May 2017 13:14:35 GMT</pubDate></item><item><title>Emacs is easy if you read code</title><link>http://blog.binchen.org/posts/emacs-is-easy-if-you-read-code.html</link><dc:creator>Chen Bin</dc:creator><description>&lt;div&gt;&lt;p&gt;
is easy if you read code                                      :en:emacs:ivy:counsel:
&lt;/p&gt;

&lt;p&gt;
If you regard a package as a collection of APIs and read its code, Emacs is easy to master.
&lt;/p&gt;

&lt;p&gt;
For example, here is a useful tip on &lt;a href="https://sam217pa.github.io/2016/09/11/nuclear-power-editing-via-ivy-and-ag/"&gt;using counsel-ag and wgrep to edit multiple files&lt;/a&gt; I recently learned.
&lt;/p&gt;

&lt;p&gt;
To &lt;b&gt;understand this black magic&lt;/b&gt;, you only need know &lt;code&gt;counsel-ag-occur&lt;/code&gt; from &lt;code&gt;counsel.el&lt;/code&gt; (v0.9.1):
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre&gt;&lt;code class="lang-lisp"&gt;(defun counsel-ag-occur ()
  "Generate a custom occur buffer for `counsel-ag'."
  (unless (eq major-mode 'ivy-occur-grep-mode)
    (ivy-occur-grep-mode))
  (setq default-directory counsel--git-grep-dir)
  (let* ((regex (counsel-unquote-regex-parens
                 (setq ivy--old-re
                       (ivy--regex
                        (progn (string-match "\"\\(.*\\)\"" (buffer-name))
                               (match-string 1 (buffer-name)))))))
         (cands (split-string
                 (shell-command-to-string
                  (format counsel-ag-base-command (shell-quote-argument regex)))
                 "\n"
                 t)))
    ;; Need precise number of header lines for `wgrep' to work.
    (insert (format "-*- mode:grep; default-directory: %S -*-\n\n\n"
                    default-directory))
    (insert (format "%d candidates:\n" (length cands)))
    (ivy--occur-insert-lines
     (mapcar
      (lambda (cand) (concat "./" cand))
      cands))))
(ivy-set-occur 'counsel-ag 'counsel-ag-occur)
(ivy-set-display-transformer 'counsel-ag 'counsel-git-grep-transformer)
&lt;/code&gt;&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;
Inside &lt;code&gt;counsel-ag-occur&lt;/code&gt;:
&lt;/p&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;The variable &lt;code&gt;regex&lt;/code&gt; is the regular expression built from the filter string you input. Please note that &lt;code&gt;regex&lt;/code&gt; is unquoted by &lt;code&gt;counsel-unquote-regex-parens&lt;/code&gt; so it can be used in shell. If you use &lt;code&gt;regex&lt;/code&gt; in Emacs Lisp, you don't need unquote it
&lt;/li&gt;
&lt;li&gt;The variable &lt;code&gt;cands&lt;/code&gt; is the candidate lines created by running &lt;code&gt;ag&lt;/code&gt; with &lt;code&gt;regex&lt;/code&gt; as parameters in shell
&lt;/li&gt;
&lt;li&gt;Then a wgrep-friendly buffer is created
&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
After spending 5 minutes to understand the internals, you can &lt;b&gt;easily implement similar features&lt;/b&gt;.
&lt;/p&gt;

&lt;p&gt;
Now let's &lt;b&gt;develop our own black magic&lt;/b&gt; by enhancing the wgrep-friendly buffer.
&lt;/p&gt;

&lt;p&gt;
My project uses Perforce as VCS. So &lt;b&gt;I need check out files and make them writable before using wgrep&lt;/b&gt;.
&lt;/p&gt;

&lt;p&gt;
Read code of &lt;code&gt;wgrep.el&lt;/code&gt; (v2.1.10),
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre&gt;&lt;code class="lang-lisp"&gt;(defun wgrep-prepare-context ()
  (save-restriction
    (let ((start (wgrep-goto-first-found))
          (end (wgrep-goto-end-of-found)))
      (narrow-to-region start end)
      (goto-char (point-min))
      (funcall wgrep-results-parser))))
&lt;/code&gt;&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;
&lt;code&gt;wgrep-results-parser&lt;/code&gt; is actually alias of &lt;code&gt;wgrep-parse-command-results&lt;/code&gt; whose code is too much to paste here. You can &lt;code&gt;M-x find-function wgrep-parse-command-results&lt;/code&gt; to read its code.
&lt;/p&gt;

&lt;p&gt;
By combining &lt;code&gt;wgrep-prepare-context&lt;/code&gt; and &lt;code&gt;wgrep-parse-command-results&lt;/code&gt; I got my own &lt;code&gt;access-files-in-wgrep-buffer&lt;/code&gt;:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre&gt;&lt;code class="lang-lisp"&gt;(defun access-files-in-wgrep-buffer()
  (interactive)
  (save-restriction
    (let* ((start (wgrep-goto-first-found))
           (end (wgrep-goto-end-of-found))
           fn-accessed)
      (narrow-to-region start end)
      (goto-char (point-min))
      (unless (featurep 'wgrep) (require 'featurep))
      (while (not (eobp))
        (if (looking-at wgrep-line-file-regexp)
            (let* ((fn (match-string-no-properties 1)))
              (unless (string= fn fn-accessed)
                (setq fn-accessed fn)
                (message "File relative path=%s" fn))))
        (forward-line 1)))))
&lt;/code&gt;&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;
You can replace the line &lt;code&gt;(message "File relative path=%s" fn)&lt;/code&gt; to &lt;code&gt;(shell-command (format "any-shell-cli %s" fn))&lt;/code&gt; to &lt;b&gt;do anything on the files&lt;/b&gt;.
&lt;/p&gt;

&lt;p&gt;
You can insert definition of &lt;code&gt;access-files-in-wgrep-buffer&lt;/code&gt; into your &lt;code&gt;.emacs&lt;/code&gt; and run &lt;code&gt;M-x access-files-in-wgrep-buffer&lt;/code&gt; in wgrep buffer to have a test.
&lt;/p&gt;

&lt;p&gt;
For example, I modified &lt;code&gt;access-files-in-wgrep-buffer&lt;/code&gt; to &lt;code&gt;p4edit-in-grep-buffer&lt;/code&gt; to checkout files under &lt;a href="https://www.perforce.com/"&gt;Perforce&lt;/a&gt; control,
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre&gt;&lt;code class="lang-emacs"&gt;(defun p4edit-in-wgrep-buffer()
  "'p4 edit' files in wgrep buffer.
Turn off `read-only-mode' of opened files."
  (interactive)
  (save-restriction
    (let* ((start (wgrep-goto-first-found))
           (end (wgrep-goto-end-of-found))
           fn-accessed)
      (narrow-to-region start end)
      (goto-char (point-min))
      (unless (featurep 'wgrep) (require 'featurep))
      (while (not (eobp))
        (if (looking-at wgrep-line-file-regexp)
            (let* ((filename (match-string-no-properties 1)) buf)
              (unless (string= filename fn-accessed)
                (setq fn-accessed filename)
                (shell-command (format "p4 edit %s" filename))
                (if (setq buf (get-file-buffer filename))
                    (with-current-buffer buf
                      ;; turn off read-only since we've already `p4 edit'
                      (read-only-mode -1))))))
        (forward-line 1)))))
&lt;/code&gt;&lt;/pre&gt;

&lt;/div&gt;&lt;/div&gt;</description><category>counsel</category><category>emacs</category><category>en</category><category>ivy</category><guid>http://blog.binchen.org/posts/emacs-is-easy-if-you-read-code.html</guid><pubDate>Tue, 09 May 2017 13:38:06 GMT</pubDate></item><item><title>Auto-complete word in Emacs mini-buffer when using Evil</title><link>http://blog.binchen.org/posts/auto-complete-word-in-emacs-mini-buffer-when-using-evil.html</link><dc:creator>Chen Bin</dc:creator><description>&lt;div&gt;&lt;p&gt;
word in Emacs mini-buffer when using Evil                       :en:emacs:evil:vim:
&lt;/p&gt;

&lt;p&gt;
When using &lt;a href="https://www.emacswiki.org/emacs/Evil"&gt;Evil&lt;/a&gt; I often input &lt;code&gt;%s/old-keyword/new-keyword/g&lt;/code&gt; in &lt;a href="https://www.gnu.org/software/emacs/manual/html_node/emacs/Minibuffer.html"&gt;Minibuffer&lt;/a&gt;.
&lt;/p&gt;

&lt;p&gt;
The problem is auto completions of &lt;code&gt;new-keyword&lt;/code&gt; using &lt;a href="http://www.gnu.org/s/emacs/manual/html_node/autotype/Hippie-Expand.html"&gt;hippie-expand&lt;/a&gt; always fail.
&lt;/p&gt;

&lt;p&gt;
It turns out that the character "/" is treated as &lt;a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Syntax-Class-Table.html"&gt;Word constituent&lt;/a&gt; in minibuffer.
&lt;/p&gt;

&lt;p&gt;
The solution is to re-define "/" as &lt;a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Syntax-Class-Table.html"&gt;Punctuation characters&lt;/a&gt;:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre&gt;&lt;code class="lang-lisp"&gt;(defun minibuffer-inactive-mode-hook-setup ()
  ;; make `try-expand-dabbrev' from `hippie-expand' work in mini-buffer
  ;; @see `he-dabbrev-beg', so we need re-define syntax for '/'
  (set-syntax-table (let* ((table (make-syntax-table)))
                      (modify-syntax-entry ?/ "." table)
                      table)))
(add-hook 'minibuffer-inactive-mode-hook 'minibuffer-inactive-mode-hook-setup)
&lt;/code&gt;&lt;/pre&gt;

&lt;/div&gt;&lt;/div&gt;</description><category>emacs</category><category>en</category><category>evil</category><category>vim</category><guid>http://blog.binchen.org/posts/auto-complete-word-in-emacs-mini-buffer-when-using-evil.html</guid><pubDate>Tue, 28 Mar 2017 12:16:06 GMT</pubDate></item></channel></rss>