<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/"><channel><title>Chen's blog (Posts about emacs)</title><link>http://blog.binchen.org/</link><description></description><atom:link href="http://blog.binchen.org/categories/emacs.xml" type="application/rss+xml" rel="self"></atom:link><language>en</language><lastBuildDate>Tue, 04 Jun 2019 13:08:39 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>dianyou 0.0.3 is out</title><link>http://blog.binchen.org/posts/dianyou-0-0-3-is-out.html</link><dc:creator>Chen Bin</dc:creator><description>&lt;div&gt;&lt;p&gt;
I created &lt;a href="https://github.com/redguardtoo/dianyou"&gt;dianyou&lt;/a&gt; (电邮) to solve improve my Gnus work flow.
&lt;/p&gt;

&lt;div id="outline-container-orged80b75" class="outline-2"&gt;
&lt;h3 id="orged80b75"&gt;Search mails&lt;/h3&gt;
&lt;div class="outline-text-2" id="text-orged80b75"&gt;
&lt;p&gt;
Most Gnus users use &lt;code&gt;gnus-group-make-nnir-group&lt;/code&gt; to search mails. But it's not usable in "Summary Buffer". Its &lt;a href="https://tools.ietf.org/html/rfc3501#section-6.4.4"&gt;IMAP SEARCH Command&lt;/a&gt; is hard to use.
&lt;/p&gt;

&lt;p&gt;
It could be replaced by &lt;code&gt;dianyou-group-make-nnir-group&lt;/code&gt; which supports shortcuts. For example, you can input "f John s 1y2w2d" and select "imap" when Gnus asks the question "Imap Search in". It means search mails from John since 1 year, 2 weeks and 2 days ago.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgdb36ad2" class="outline-2"&gt;
&lt;h3 id="orgdb36ad2"&gt;Auto complete email address&lt;/h3&gt;
&lt;div class="outline-text-2" id="text-orgdb36ad2"&gt;
&lt;p&gt;
I'm too lazy to set up my contacts. It would be better that Gnus could &lt;b&gt;automatically&lt;/b&gt; collect email addresses from all received mails. So I created the command &lt;code&gt;dianyou-insert-email-address-from-received-mails&lt;/code&gt;. The inserted email address is also inserted into the global variable &lt;code&gt;dianyou-email-address-history&lt;/code&gt; which could be persisted by &lt;a href="https://github.com/jwiegley/session"&gt;session&lt;/a&gt;.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orga91f867" class="outline-2"&gt;
&lt;h3 id="orga91f867"&gt;Switch Gnus buffer&lt;/h3&gt;
&lt;div class="outline-text-2" id="text-orga91f867"&gt;
&lt;p&gt;
One annoying thing in Gnus is pressing "q" will close opened folder. I often pressed "q" when I only intended to switch to another Gnus buffer. Now I can use &lt;code&gt;dianyou-switch-gnus-buffer&lt;/code&gt;.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgdff2081" class="outline-2"&gt;
&lt;h3 id="orgdff2081"&gt;Paste image from clipboard&lt;/h3&gt;
&lt;div class="outline-text-2" id="text-orgdff2081"&gt;
&lt;p&gt;
Use &lt;code&gt;dianyou-paste-image-from-clipboard&lt;/code&gt;. CLI program &lt;a href="https://github.com/astrand/xclip"&gt;xclip&lt;/a&gt; should be installed at first.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;</description><category>emacs</category><category>email</category><category>en</category><category>gnus</category><guid>http://blog.binchen.org/posts/dianyou-0-0-3-is-out.html</guid><pubDate>Tue, 04 Jun 2019 12:54:48 GMT</pubDate></item><item><title>My favorite Richard Stallman interviews</title><link>http://blog.binchen.org/posts/my-favourite-richard-stallman-interviews.html</link><dc:creator>Chen Bin</dc:creator><description>&lt;div&gt;&lt;p&gt;
I've watched/listened many Richard Stallman interviews. Some hosts are really bad. They know nothing about technology and are too aggressive.
&lt;/p&gt;

&lt;p&gt;
But good interviewers still exist. Here are top 3 interviews I recommend:
&lt;/p&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;a href="http://hackerpublicradio.org/eps.php?id=1116"&gt;Interview with Richard Stallman&lt;/a&gt; from Hacker Public Radio. The interviewer is technical by himself so he can ask right questions and understand answers immediately.&lt;/li&gt;

&lt;li&gt;&lt;a href="https://www.youtube.com/watch?v=NB8mCcLRxlg"&gt;Richard Stallman on Free Software: Freedom is Worth the Inconvenience&lt;/a&gt; from Singularity Weblog. Nikola Danaylov focus more on ethic perspective of technology.&lt;/li&gt;

&lt;li&gt;&lt;a href="https://www.youtube.com/watch?v=JQbrQTc3jxM"&gt;Dr Diane Hamilton Interviews Richard Stallman&lt;/a&gt;. Diane Hamilton is good listener and just let Richard Stallman talk. Stallman quoted text from Chinese ancient novel San Guo (Three Kingdom) in the interview.&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</description><category>emacs</category><category>en</category><category>gnu</category><guid>http://blog.binchen.org/posts/my-favourite-richard-stallman-interviews.html</guid><pubDate>Mon, 13 May 2019 14:33:32 GMT</pubDate></item><item><title>Enhance Emacs Evil global markers</title><link>http://blog.binchen.org/posts/enhance-emacs-evil-global-markers.html</link><dc:creator>Chen Bin</dc:creator><description>&lt;div&gt;&lt;p&gt;
Global evil marker is saved in &lt;code&gt;evil-global-markers-history&lt;/code&gt; by &lt;a href="https://github.com/jwiegley/session"&gt;session.el&lt;/a&gt;.
&lt;/p&gt;

&lt;p&gt;
Insert below code int &lt;code&gt;~/.emacs&lt;/code&gt;,
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre&gt;&lt;code class="lang-lisp"&gt;(defvar evil-global-markers-history nil)
(defun my-forward-line (lnum)
  "Forward LNUM lines."
  (setq lnum (string-to-number lnum))
  (when (and lnum (&amp;gt; lnum 0))
    (goto-char (point-min))
    (forward-line (1- lnum))))

(defadvice evil-set-marker (before evil-set-marker-before-hack activate)
  (let* ((args (ad-get-args 0))
         (c (nth 0 args))
         (pos (or (nth 1 args) (point))))
    ;; only rememeber global markers
    (when (and (&amp;gt;= c ?A) (&amp;lt;= c ?Z) buffer-file-name)
      (setq evil-global-markers-history
            (delq nil
                  (mapcar `(lambda (e)
                             (unless (string-match (format "^%s@" (char-to-string ,c)) e)
                               e))
                          evil-global-markers-history)))
      (setq evil-global-markers-history
            (add-to-list 'evil-global-markers-history
                         (format "%s@%s:%d:%s"
                                 (char-to-string c)
                                 (file-truename buffer-file-name)
                                 (line-number-at-pos pos)
                                 (string-trim (buffer-substring-no-properties (line-beginning-position)
                                                                              (line-end-position)))))))))

(defadvice evil-goto-mark-line (around evil-goto-mark-line-hack activate)
  (let* ((args (ad-get-args 0))
         (c (nth 0 args))
         (orig-pos (point)))

    (condition-case nil
        ad-do-it
      (error (progn
               (when (and (eq orig-pos (point)) evil-global-markers-history)
                 (let* ((markers evil-global-markers-history)
                        (i 0)
                        m
                        file
                        found)
                   (while (and (not found) (&amp;lt; i (length markers)))
                     (setq m (nth i markers))
                     (when (string-match (format "\\`%s@\\(.*?\\):\\([0-9]+\\):\\(.*\\)\\'"
                                                 (char-to-string c))
                                         m)
                       (setq file (match-string-no-properties 1 m))
                       (setq found (match-string-no-properties 2 m)))
                     (setq i (1+ i)))
                   (when file
                     (find-file file)
                     (my-forward-line found)))))))))

(defun counsel-evil-goto-global-marker ()
  "Goto global evil marker."
  (interactive)
  (unless (featurep 'ivy) (require 'ivy))
  (ivy-read "Goto global evil marker"
            evil-global-markers-history
            :action (lambda (m)
                      (when (string-match "\\`[A-Z]@\\(.*?\\):\\([0-9]+\\):\\(.*\\)\\'" m)
                        (let* ((file (match-string-no-properties 1 m))
                               (linenum (match-string-no-properties 2 m)))
                          (find-file file)
                          (my-forward-line linenum))))))
&lt;/code&gt;&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;
&lt;code&gt;evil-goto-mark-line&lt;/code&gt; will access marker in &lt;code&gt;evil-global-markers-history&lt;/code&gt;.&lt;/p&gt;&lt;/div&gt;</description><category>emacs</category><category>en</category><category>evil</category><guid>http://blog.binchen.org/posts/enhance-emacs-evil-global-markers.html</guid><pubDate>Mon, 08 Apr 2019 13:00:53 GMT</pubDate></item><item><title>Steps to install Emacs 27 for testing</title><link>http://blog.binchen.org/posts/wucuo-a-emacs-spell-checker-that-works-with-camel-case-code.html</link><dc:creator>Chen Bin</dc:creator><description>&lt;div&gt;&lt;p&gt;
The Emacs is not for daily usage. Only for testing.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre&gt;&lt;code class="lang-bash"&gt;sudo apt install built-essential automake autoconf texinfo # optional if they are already installed
git clone https://git.savannah.gnu.org/git/emacs.git
cd emacs &amp;amp;&amp;amp; ./configure CFLAGS=-no-pie --without-x --without-dbus --without-sound --with-gnutls=no &amp;amp;&amp;amp; make
src/emacs # start emacs
&lt;/code&gt;&lt;/pre&gt;

&lt;/div&gt;&lt;/div&gt;</description><category>emacs</category><category>en</category><guid>http://blog.binchen.org/posts/wucuo-a-emacs-spell-checker-that-works-with-camel-case-code.html</guid><pubDate>Fri, 07 Sep 2018 12:39:54 GMT</pubDate></item><item><title>How to spell check function/variable in Emacs</title><link>http://blog.binchen.org/posts/how-to-spell-check-functionvariable-in-emacs.html</link><dc:creator>Chen Bin</dc:creator><description>&lt;div&gt;&lt;p&gt;
CREATED: &lt;span class="timestamp-wrapper"&gt;&lt;span class="timestamp"&gt;&amp;lt;2018-06-17 Sun&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;/p&gt;

&lt;p&gt;
UPDATED: &lt;span class="timestamp-wrapper"&gt;&lt;span class="timestamp"&gt;&amp;lt;2019-04-04 Thu&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;/p&gt;

&lt;p&gt;
&lt;a href="http://blog.binchen.org/posts/effective-spell-check-in-emacs.html"&gt;This article&lt;/a&gt; explains how to spell check camel cased names of functions and variables in Emacs. It uses options &lt;code&gt;--run-together&lt;/code&gt; from &lt;a href="http://aspell.net/"&gt;GNU Aspell&lt;/a&gt;.
&lt;/p&gt;

&lt;p&gt;
But this solution is not perfect. It wrongly identifies two character sub-word as typo. For example, "onChange" is regarded as typo because the sub-word "on" is identified as typo. Another issue is namespace of function name. For example, "MS" from "MSToggleButton" is alias of "Microsoft". If "MS" is identified as typo, every word containing "MS" is regarded as typo.
&lt;/p&gt;

&lt;p&gt;
In this article,
&lt;/p&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;I will explain &lt;b&gt;how Emacs spell checker works&lt;/b&gt;&lt;/li&gt;
&lt;li&gt;Then we study the &lt;b&gt;algorithm of aspell&lt;/b&gt;&lt;/li&gt;
&lt;li&gt;Finally, &lt;b&gt;a complete solution&lt;/b&gt; which works with &lt;b&gt;both aspell and hunspell&lt;/b&gt; is provided&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
Emacs built in plugin &lt;a href="https://www.emacswiki.org/emacs/FlySpell"&gt;Fly Spell&lt;/a&gt; does spell checking. It passes the options and plain text to command line tool aspell. Aspell sends back the typos into &lt;code&gt;Fly Spell&lt;/code&gt;. &lt;code&gt;Fly Spell&lt;/code&gt; then picks up typos to display. For example, &lt;a href="https://www.gnu.org/software/emacs/manual/html_node/emacs/Spelling.html"&gt;flyspell-prog-mode&lt;/a&gt; only displays typos in comments and strings.
&lt;/p&gt;

&lt;p&gt;
Aspell doesn't understand syntax of any programming language. It simply reports typos in plain text.
&lt;/p&gt;

&lt;p&gt;
Aspell has two options:
&lt;/p&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;code&gt;--run-together-limit&lt;/code&gt; is "Maximum number of words can be strung together"&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--run-together-min&lt;/code&gt; is "Minimal length of sub-words"&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
Aspell C++ code has to be studied in order to understand above two options. Let's start from &lt;code&gt;Working::check_word&lt;/code&gt; in &lt;code&gt;modules/speller/default/suggest.cpp&lt;/code&gt;.
&lt;/p&gt;

&lt;p&gt;
Here is code,
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre&gt;&lt;code class="lang-c"&gt;class Working : public Score {
  unsigned check_word(char * word, char * word_end, CheckInfo * ci, unsigned pos = 1);
};
unsigned Working::check_word(char * word, char * word_end,  CheckInfo * ci,
                             /* it WILL modify word */
                             unsigned pos)
{
  // check the whole word before go into run-together mode
  unsigned res = check_word_s(word, ci);
  // if `res` is true, it's a valid word, don't bother run-together
  if (res) return pos + 1;
  // it's typo because number of sub-words is greater than "--run-together-limit"
  if (pos + 1 &amp;gt;= sp-&amp;gt;run_together_limit_) return 0;

  // `i` is the `end` of sub-word, the poition AFTER last character of sub-word
  for (char * i = word + sp-&amp;gt;run_together_min_; 
       // already checked the whole word; besides, any sub-word whose size is less 
       // than "--run-together-min" is regarded as invalid
       i &amp;lt;= word_end - sp-&amp;gt;run_together_min_;
       ++i)
  {
    char t = *i;

    // read the sub-word by set the character at `end` position to '\0'
    *i = '\0';
    res = check_word_s(word, ci);
    // restore original character at `end` position
    *i = t;

    // Current sub-word is invalid, we need append the character at current
    //  `end` position to creata new sub-word.
    //  Inncrement `i` because `i` always points to the `end` of sub-word
    if (!res) continue;

    // Current sub-word is valid, strip it from the whole word to create a totally
    // new word for `check_word`, `check_word` is a recursive function
    res = check_word(i, word_end, ci + 1, pos + 1);
    if (res) return res;
  }
  memset(ci, 0, sizeof(CheckInfo));
  return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;
Say first parameter of &lt;code&gt;check_word&lt;/code&gt; is "hisHelle",
&lt;/p&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;code&gt;word&lt;/code&gt; points to string "hisHelle" (in C/C++, string is character array. The last character of array is character &lt;code&gt;'\0'&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sp-&amp;gt;run_together_min_&lt;/code&gt; is 3, so &lt;code&gt;i&lt;/code&gt; initially points to the character "H", at the end of sub-word "his"&lt;/li&gt;
&lt;li&gt;&lt;code&gt;check_word_s&lt;/code&gt; return &lt;code&gt;true&lt;/code&gt; for sub-word "his"&lt;/li&gt;
&lt;li&gt;So we strip "his" from "hisHelle" and recursively call &lt;code&gt;check_word&lt;/code&gt; to check new word "Helle"&lt;/li&gt;
&lt;li&gt;In the new context of &lt;code&gt;check_word&lt;/code&gt;, we extract "Hel" from "Helle" initially&lt;/li&gt;
&lt;li&gt;"Hel" is invalid. So "Hell" is extracted from "Helle". The remaining charcter "e" is a treated as as new word with &lt;code&gt;check_word&lt;/code&gt; recursively applying on it&lt;/li&gt;
&lt;li&gt;"e" is not valid It's the last word could be extracted. So recursion is over. It's concluded that "hisHelle" is a typo&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
Key points:
&lt;/p&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;code&gt;--run-together-limit&lt;/code&gt; could be bigger with enough memory. It's default value is 8. I prefer 16.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--run-together-min&lt;/code&gt; can't be 2 because too many typos are combination of "correct" two character sub-words ("hehe", "isme", …)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--run-together-min&lt;/code&gt; can't be greater than 3, or else, too many "correct" three character sub-words are regarded as invalid ("his", "her", "one", "two")&lt;/li&gt;
&lt;li&gt;So &lt;code&gt;--run-together-min&lt;/code&gt; &lt;b&gt;should always be 3&lt;/b&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
If &lt;code&gt;--run-together-min&lt;/code&gt; is 3, the word "onChange" is typo because the first two characters "on" is typo by aspell. This is obviously wrong.
&lt;/p&gt;

&lt;p&gt;
The solution is a Emacs Lisp predicate which supports &lt;b&gt;both aspell and hunspell&lt;/b&gt;.
&lt;/p&gt;

&lt;p&gt;
A predicate could be attached to specific major-mode. The predicate file all the typos reported by CLI program. If predicate returns  &lt;code&gt;t&lt;/code&gt;, the feed in typo is finally approved to be typo,
&lt;/p&gt;

&lt;p&gt;
A example of predicate for &lt;code&gt;js2-mode&lt;/code&gt;,
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre&gt;&lt;code class="lang-lisp"&gt;(defun js-flyspell-verify ()
  (let* ((font-face (get-text-property (- (point) 1) 'face))
         (word (thing-at-point 'word)))
    (message "font-face=%s word=%s" font-face word)
    t))
(put 'js2-mode 'flyspell-mode-predicate 'js-flyspell-verify)
&lt;/code&gt;&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;
Typo candidates are filtered by &lt;code&gt;js-flyspell-verify&lt;/code&gt;. So predicate is where to fix typos wrongly reported by CLI program.
&lt;/p&gt;

&lt;p&gt;
Here is complete setup you can paste into &lt;code&gt;.emacs&lt;/code&gt; (I setup for &lt;code&gt;js2-mode&lt;/code&gt; and &lt;code&gt;rjsx-mode&lt;/code&gt; but code is generic enough).
&lt;/p&gt;

&lt;p&gt;
Please note function &lt;code&gt;split-camel-case&lt;/code&gt; splits a camel case word into a list of sub-words. Sub-word with less one or two characters is not typo.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre&gt;&lt;code class="lang-lisp"&gt;(defun split-camel-case (word)
  "Split camel case WORD into a list of strings.
Ported from 'https://github.com/fatih/camelcase/blob/master/camelcase.go'."
  (let* ((case-fold-search nil)
         (len (length word))
         ;; ten sub-words is enough
         (runes [nil nil nil nil nil nil nil nil nil nil])
         (runes-length 0)
         (i 0)
         ch
         (last-class 0)
         (class 0)
         rlt)

    ;; split into fields based on class of character
    (while (&amp;lt; i len)
      (setq ch (elt word i))
      (cond
       ;; lower case
       ((and (&amp;gt;= ch ?a) (&amp;lt;= ch ?z))
        (setq class 1))
       ;; upper case
       ((and (&amp;gt;= ch ?A) (&amp;lt;= ch ?Z))
        (setq class 2))
       ((and (&amp;gt;= ch ?0) (&amp;lt;= ch ?9))
        (setq class 3))
       (t
        (setq class 4)))

      (cond
       ((= class last-class)
        (aset runes
              (1- runes-length)
              (concat (aref runes (1- runes-length)) (char-to-string ch))))
       (t
        (aset runes runes-length (char-to-string ch))
        (setq runes-length (1+ runes-length))))
      (setq last-class class)
      ;; end of while
      (setq i (1+ i)))

    ;; handle upper case -&amp;gt; lower case sequences, e.g.
    ;;     "PDFL", "oader" -&amp;gt; "PDF", "Loader"
    (setq i 0)
    (while (&amp;lt; i (1- runes-length))
      (let* ((ch-first (aref (aref runes i) 0))
             (ch-second (aref (aref runes (1+ i)) 0)))
        (when (and (and (&amp;gt;= ch-first ?A) (&amp;lt;= ch-first ?Z))
                   (and (&amp;gt;= ch-second ?a) (&amp;lt;= ch-second ?z)))
          (aset runes (1+ i) (concat (substring (aref runes i) -1) (aref runes (1+ i))))
          (aset runes i (substring (aref runes i) 0 -1))))
      (setq i (1+ i)))

    ;; construct final result
    (setq i 0)
    (while (&amp;lt; i runes-length)
      (when (&amp;gt; (length (aref runes i)) 0)
        (setq rlt (add-to-list 'rlt (aref runes i) t)))
      (setq i (1+ i)))
     rlt))

(defun flyspell-detect-ispell-args (&amp;amp;optional run-together)
  "If RUN-TOGETHER is true, spell check the CamelCase words.
Please note RUN-TOGETHER will make aspell less capable. So it should only be used in prog-mode-hook."
  ;; force the English dictionary, support Camel Case spelling check (tested with aspell 0.6)
  (let* ((args (list "--sug-mode=ultra" "--lang=en_US"))args)
    (if run-together
        (setq args (append args '("--run-together" "--run-together-limit=16"))))
    args))

;; {{ for aspell only, hunspell does not need setup `ispell-extra-args'
(setq ispell-program-name "aspell")
(setq-default ispell-extra-args (flyspell-detect-ispell-args t))
;; }}

;; ;; {{ hunspell setup, please note we use dictionary "en_US" here
;; (setq ispell-program-name "hunspell")
;; (setq ispell-local-dictionary "en_US")
;; (setq ispell-local-dictionary-alist
;;       '(("en_US" "[[:alpha:]]" "[^[:alpha:]]" "[']" nil ("-d" "en_US") nil utf-8)))
;; ;; }}

(defvar extra-flyspell-predicate '(lambda (word) t)
  "A callback to check WORD.  Return t if WORD is typo.")

(defun my-flyspell-predicate (word)
  "Use aspell to check WORD.  If it's typo return t."
  (let* ((cmd (cond
               ;; aspell: `echo "helle world" | aspell pipe`
               ((string-match-p "aspell$" ispell-program-name)
                (format "echo \"%s\" | %s pipe"
                        word
                        ispell-program-name))
               ;; hunspell: `echo "helle world" | hunspell -a -d en_US`
               (t
                (format "echo \"%s\" | %s -a -d en_US"
                        word
                        ispell-program-name))))
         (cmd-output (shell-command-to-string cmd))
         rlt)
    ;; (message "word=%s cmd=%s" word cmd)
    ;; (message "cmd-output=%s" cmd-output)
    (cond
     ((string-match-p "^&amp;amp;" cmd-output)
      ;; it's a typo because at least one sub-word is typo
      (setq rlt t))
     (t
      ;; not a typo
      (setq rlt nil)))
    rlt))

(defun js-flyspell-verify ()
  (let* ((case-fold-search nil)
         (font-matched (memq (get-text-property (- (point) 1) 'face)
                             '(js2-function-call
                               js2-function-param
                               js2-object-property
                               js2-object-property-access
                               font-lock-variable-name-face
                               font-lock-string-face
                               font-lock-function-name-face
                               font-lock-builtin-face
                               rjsx-text
                               rjsx-tag
                               rjsx-attr)))
         subwords
         word
         (rlt t))
    (cond
     ((not font-matched)
      (setq rlt nil))
     ;; ignore two character word
     ((&amp;lt; (length (setq word (thing-at-point 'word))) 2)
      (setq rlt nil))
     ;; handle camel case word
     ((and (setq subwords (split-camel-case word)) (&amp;gt; (length subwords) 1))
      (let* ((s (mapconcat (lambda (w)
                             (cond
                              ;; sub-word wholse length is less than three
                              ((&amp;lt; (length w) 3)
                               "")
                               ;; special characters
                              ((not (string-match-p "^[a-zA-Z]*$" w))
                               "")
                              (t
                               w))) subwords " ")))
        (setq rlt (my-flyspell-predicate s))))
     (t
      (setq rlt (funcall extra-flyspell-predicate word))))
    rlt))

(put 'js2-mode 'flyspell-mode-predicate 'js-flyspell-verify)
(put 'rjsx-mode 'flyspell-mode-predicate 'js-flyspell-verify)
&lt;/code&gt;&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;
&lt;b&gt;UPDATE:&lt;/b&gt;
Now you can use &lt;a href="https://github.com/redguardtoo/wucuo"&gt;wucuo&lt;/a&gt;. It's an out of box solution supporting both aspell and hunspell.&lt;/p&gt;&lt;/div&gt;</description><category>emacs</category><category>en</category><category>flyspell</category><guid>http://blog.binchen.org/posts/how-to-spell-check-functionvariable-in-emacs.html</guid><pubDate>Sun, 17 Jun 2018 03:16:41 GMT</pubDate></item><item><title>Use Imenu to list comments in current buffer</title><link>http://blog.binchen.org/posts/use-imenu-to-list-comments-in-current-buffer.html</link><dc:creator>Chen Bin</dc:creator><description>&lt;div&gt;&lt;p&gt;
&lt;a href="https://github.com/redguardtoo/evil-nerd-commenter"&gt;evil-nerd-commenter&lt;/a&gt; v3.2.0 has a new function &lt;code&gt;evilnc-imenu-create-index-function&lt;/code&gt;.
&lt;/p&gt;

&lt;p&gt;
&lt;a href="http://www.gnu.org/s/emacs/manual/html_node/emacs/Imenu.html"&gt;Imenu&lt;/a&gt; could use this function to list all comments in current file.
&lt;/p&gt;

&lt;p&gt;
Usage:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre&gt;&lt;code class="lang-lisp"&gt;(require 'counsel)
(defun counsel-imenu-comments ()
  "Imenu display comments."
  (interactive)
  (let* ((imenu-create-index-function 'evilnc-imenu-create-index-function))
    (counsel-imenu)))
&lt;/code&gt;&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;
Screen cast:
&lt;/p&gt;

&lt;div class="figure"&gt;
&lt;p&gt;&lt;img src="http://blog.binchen.org/wp-content/counsel-imenu-comments.gif" alt="counsel-imenu-comments.gif"&gt;
&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;</description><category>emacs</category><category>en</category><category>imenu</category><guid>http://blog.binchen.org/posts/use-imenu-to-list-comments-in-current-buffer.html</guid><pubDate>Sun, 08 Apr 2018 02:12:04 GMT</pubDate></item><item><title>counsel-etags v1.3.1 is released</title><link>http://blog.binchen.org/posts/counsel-etags-v1-3-1-is-released-enemacsctags.html</link><dc:creator>Chen Bin</dc:creator><description>&lt;div&gt;&lt;p&gt;
&lt;a href="https://github.com/redguardtoo/counsel-etags"&gt;Counsel-etags&lt;/a&gt; is a complete solution for code navigation in Emacs.
&lt;/p&gt;

&lt;p&gt;
It needs no setup. One command &lt;code&gt;counsel-etags-find-tag-at-point&lt;/code&gt; is enough to start code navigation immediately.
&lt;/p&gt;

&lt;p&gt;
It solves all problems using Ctags/Etags with Emacs.
&lt;/p&gt;

&lt;p&gt;
&lt;b&gt;Problem 1:&lt;/b&gt; Ctags takes a few seconds to update the tags file (the index file to lookup tags). The updating process blocks the user's further interaction. This problem is solved by the virtual updating function from &lt;code&gt;counsel-etags&lt;/code&gt;. The setup is simple:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre&gt;&lt;code class="lang-lisp"&gt;;; Don't ask before rereading the TAGS files if they have changed
(setq tags-revert-without-query t)
;; Don't warn when TAGS files are large
(setq large-file-warning-threshold nil)
;; Setup auto update now
(add-hook 'prog-mode-hook
  (lambda ()
    (add-hook 'after-save-hook
              'counsel-etags-virtual-update-tags 'append 'local)))
(add-hook 'after-save-hook 'counsel-etags-virtual-update-tags)
&lt;/code&gt;&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;
&lt;b&gt;Problem 2:&lt;/b&gt; Tag lookup may fail if the latest code is not scanned yet. This problem is solved by running &lt;code&gt;counsel-etags-grep&lt;/code&gt; &lt;b&gt;automatically&lt;/b&gt; if &lt;code&gt;counsel-etags-find-tag-at-point&lt;/code&gt; fails. So users always get results.
&lt;/p&gt;

&lt;p&gt;
There are also other enhancements.
&lt;/p&gt;

&lt;p&gt;
&lt;b&gt;Enhancement 1:&lt;/b&gt; Levenshtein Distance algorithm is used to place the better matching candidates at the the top. For example, a function named &lt;code&gt;renderTable&lt;/code&gt; could be defined all around in a ReactJS project. But it's very possible the user prefers the definition in same component or same folder where she triggers code navigation.
&lt;/p&gt;

&lt;p&gt;
&lt;b&gt;Enhancement 2:&lt;/b&gt; It's inefficient to search the same tag again and again. &lt;code&gt;counsel-etags-recent-tag&lt;/code&gt; is used to jump to previous definitions.
&lt;/p&gt;

&lt;p&gt;
&lt;b&gt;Enhancement 3:&lt;/b&gt; &lt;a href="https://github.com/abo-abo/swiper"&gt;Ivy-mode&lt;/a&gt; provides filter UI for &lt;code&gt;counsel-etags&lt;/code&gt;. Its means all the functionalities from Ivy is also available. For example, users can input "!keyword1" to &lt;b&gt;exclude&lt;/b&gt; candidates matching "keyword1".
&lt;/p&gt;

&lt;p&gt;
&lt;b&gt;Enhancement 4:&lt;/b&gt; &lt;code&gt;counsel-etags-grep&lt;/code&gt; uses the fastest grep program &lt;a href="https://github.com/BurntSushi/ripgrep"&gt;ripgrep&lt;/a&gt; if it's installed. Or else it falls back to standard grep.
&lt;/p&gt;

&lt;p&gt;
Please check &lt;a href="https://github.com/redguardtoo/counsel-etags"&gt;https://github.com/redguardtoo/counsel-etags&lt;/a&gt; for more tips.&lt;/p&gt;&lt;/div&gt;</description><category>emacs</category><category>en</category><category>etags</category><guid>http://blog.binchen.org/posts/counsel-etags-v1-3-1-is-released-enemacsctags.html</guid><pubDate>Sun, 12 Nov 2017 09:40:15 GMT</pubDate></item><item><title>Auto complete everything in Emacs</title><link>http://blog.binchen.org/posts/auto-complete-everything-in-emacs.html</link><dc:creator>Chen Bin</dc:creator><description>&lt;div&gt;&lt;p&gt;
As a web developer using modern front end framework like React/Angular, I spend a lot of time on web components. 
&lt;/p&gt;

&lt;p&gt;
A component instance is like:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre&gt;&lt;code class="lang-javascript"&gt;&amp;lt;GenericTable
  onSelectRow={ row =&amp;gt; console.log(row) }
  numberOfPinnedColumns={2}
  withToolBar
  onClickCell={ cell =&amp;gt; console.log(cell) }
&amp;gt;
  &amp;lt;PaginationButtons /&amp;gt;
  &amp;lt;TotalSum /&amp;gt;
  &amp;lt;ReportButtons /&amp;gt;
&amp;lt;/GenericTable&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;
Basically a component instance is a big chunk of html tags.
&lt;/p&gt;

&lt;p&gt;
I created a new package &lt;a href="https://github.com/redguardtoo/eacl"&gt;EACL&lt;/a&gt; (Emacs auto complete lines) which could help me &lt;b&gt;input components in unbelievable speed&lt;/b&gt;.
&lt;/p&gt;

&lt;p&gt;
The idea is simple. If I've already used one component elsewhere in the project. It's unnecessary to re-type the similar code again.
&lt;/p&gt;

&lt;p&gt;
All I need to do is to input the first characters of the component and run &lt;code&gt;M-x eacl-complete-tag&lt;/code&gt; which will grep the project and input the remaining part of component.
&lt;/p&gt;

&lt;p&gt;
Here is a demo to input component &lt;code&gt;ButtonToolbar&lt;/code&gt;:
&lt;/p&gt;

&lt;div class="figure"&gt;
&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/redguardtoo/eacl/master/eacl-demo.gif" alt="eacl-demo.gif"&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;
Please note &lt;code&gt;EACL&lt;/code&gt; is generic and can be use in any programming language. 
&lt;/p&gt;

&lt;p&gt;
&lt;code&gt;M-x eacl-complete-statement&lt;/code&gt; to &lt;b&gt;complete below Javascript code&lt;/b&gt;:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre&gt;&lt;code class="lang-javascript"&gt;import {
  Button,
  Row,
  Column
} from 'react-bootstrap';
&lt;/code&gt;&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;
&lt;code&gt;M-x eacl-complete-snippet&lt;/code&gt; to &lt;b&gt;complete below C code&lt;/b&gt;:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre&gt;&lt;code class="lang-c"&gt;static int v9fs_drop_inode(struct inode *inode)
{
    struct v9fs_session_info *v9ses;
    v9ses = v9fs_inode2v9ses(inode);
    if (v9ses-&amp;gt;cache == CACHE_LOOSE || v9ses-&amp;gt;cache == CACHE_FSCACHE)
        return generic_drop_inode(inode);
    /*
     * in case of non cached mode always drop the
     * the inode because we want the inode attribute
     * to always match that on the server.
     */
    return 1;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;
You can also create your own commands based on API &lt;code&gt;eacl-complete-multi-lines-internal&lt;/code&gt;.
&lt;/p&gt;

&lt;p&gt;
For example, it is a piece of cake to support Lisp by creating comand &lt;code&gt;my-complete-lisp&lt;/code&gt;:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre&gt;&lt;code class="lang-lisp"&gt;(require 'eacl)
(defun my-complete-lisp ()
  (interactive)
  (eacl-complete-multi-lines-internal "[^)]*)"))
&lt;/code&gt;&lt;/pre&gt;

&lt;/div&gt;&lt;/div&gt;</description><category>emacs</category><category>en</category><guid>http://blog.binchen.org/posts/auto-complete-everything-in-emacs.html</guid><pubDate>Mon, 30 Oct 2017 11:13:30 GMT</pubDate></item><item><title>Split Emacs window with certain ratio</title><link>http://blog.binchen.org/posts/split-emacs-window-with-certain-ratio.html</link><dc:creator>Chen Bin</dc:creator><description>&lt;div&gt;&lt;p&gt;
The idea comes from &lt;a href="https://github.com/redguardtoo/emacs.d/issues/607"&gt;yangdaweihit&lt;/a&gt;. Here is the implementation.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre&gt;&lt;code class="lang-lisp"&gt;(defvar my-ratio-dict
  '((1 . 1.61803398875)
    (2 . 2)
    (3 . 3)
    (4 . 4)
    (5 . 0.61803398875))
  "The ratio dictionary.")

(defun my-split-window-horizontally (&amp;amp;optional ratio)
  "Split window horizontally and resize the new window.
Always focus bigger window."
  (interactive "P")
  (let* (ratio-val)
    (cond
     (ratio
      (setq ratio-val (cdr (assoc ratio my-ratio-dict)))
      (split-window-horizontally (floor (/ (window-body-width)
                                           (1+ ratio-val)))))
     (t
      (split-window-horizontally)))
    (set-window-buffer (next-window) (other-buffer))
    (if (or (not ratio-val)
            (&amp;gt;= ratio-val 1))
        (windmove-right))))

(defun my-split-window-vertically (&amp;amp;optional ratio)
  "Split window vertically and resize the new window.
Always focus bigger window."
  (interactive "P")
  (let* (ratio-val)
    (cond
     (ratio
      (setq ratio-val (cdr (assoc ratio my-ratio-dict)))
      (split-window-vertically (floor (/ (window-body-height)
                                         (1+ ratio-val)))))
     (t
      (split-window-vertically)))
    ;; open another window with other-buffer
    (set-window-buffer (next-window) (other-buffer))
    ;; move focus if new window bigger than current one
    (if (or (not ratio-val)
            (&amp;gt;= ratio-val 1))
        (windmove-down))))

(global-set-key (kbd "C-x 2") 'my-split-window-vertically)
(global-set-key (kbd "C-x 3") 'my-split-window-horizontally)
&lt;/code&gt;&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;
Usage is simple. For example, &lt;code&gt;C-x 2&lt;/code&gt; is similar to original &lt;code&gt;split-winddow-vertically&lt;/code&gt; while &lt;code&gt;C-u 1 C-x 2&lt;/code&gt; split the window in golden ratio.
&lt;/p&gt;&lt;/div&gt;</description><category>emacs</category><category>en</category><guid>http://blog.binchen.org/posts/split-emacs-window-with-certain-ratio.html</guid><pubDate>Tue, 05 Sep 2017 13:26:55 GMT</pubDate></item><item><title>Enhance diff-mode with Ivy</title><link>http://blog.binchen.org/posts/enhance-diff-mode-with-ivy.html</link><dc:creator>Chen Bin</dc:creator><description>&lt;div&gt;&lt;p&gt;
My current job requires me to review the freelancer's patches and apply them to our code branch under &lt;a href="https://www.perforce.com/"&gt;Perforce&lt;/a&gt; control. Due to my client's security policy, the freelancer can only work on isolated sandbox environment and can't access our code base directly.
&lt;/p&gt;

&lt;p&gt;
I need two steps to finish the task:
&lt;/p&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;Open the freelancer's patch in &lt;code&gt;diff-mode&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Run &lt;code&gt;diff-apply-hunk&lt;/code&gt; to apply the hunks interactively&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
The problem is &lt;code&gt;diff-mode&lt;/code&gt; always ask me to specify the file to be patched.
&lt;/p&gt;

&lt;p&gt;
I read the code of &lt;code&gt;diff-apply-hunk&lt;/code&gt;. The logic of &lt;code&gt;diff-apply-hunk&lt;/code&gt; is simple. It tries different algorithms to guess the right file to patch. When the algorithms fail, it calls API &lt;code&gt;read-file-name&lt;/code&gt; to ask me to provide the file path manually. If right file is found, the algorithms will work again and &lt;code&gt;read-file-name&lt;/code&gt; will never be used for other hunks.
&lt;/p&gt;

&lt;p&gt;
Here is my solution. I can find the file to patch in recent opened files because I store all of them by &lt;code&gt;(setq recentf-max-saved-items 2048)&lt;/code&gt;. I plan to use &lt;code&gt;ivy-read&lt;/code&gt; from &lt;a href="https://github.com/abo-abo/swiper"&gt;Ivy&lt;/a&gt; to locate the file at first. If this step fails , I can still fall back on original API &lt;code&gt;read-file-name&lt;/code&gt;.
&lt;/p&gt;

&lt;p&gt;
Here is the code
&lt;/p&gt;

&lt;pre class="example"&gt;

&lt;/pre&gt;

&lt;div class="org-src-container"&gt;

&lt;pre&gt;&lt;code class="lang-lisp"&gt;(defvar ffip-read-file-name-hijacked-p nil)
(defun ffip-diff-apply-hunk (&amp;amp;optional reverse)
  (interactive "P")
  (unless recentf-mode (recentf-mode 1))
  (setq ffip-read-file-name-hijacked-p t)
  (defadvice read-file-name (around ffip-read-file-name-hack activate)
    (cond
     (ffip-read-file-name-hijacked-p
      (let* ((args (ad-get-args 0))
             (file-name (file-name-nondirectory (nth 2 args)))
             (cands (remove nil (mapcar (lambda (s) (if (string-match-p (format "%s$" file-name) s) s))
                                        (mapcar #'substring-no-properties recentf-list))))
             (rlt (ivy-read "Recentf: " cands)))
        (if rlt (setq ad-return-value rlt) rlt ad-doit)))
     (t
      ad-do-it)))
  (diff-apply-hunk reverse)
  (setq ffip-read-file-name-hijacked-p nil))
&lt;/code&gt;&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;
Please note &lt;code&gt;ffip-diff-apply-hunk&lt;/code&gt; can replace &lt;code&gt;diff-apply-hunk&lt;/code&gt;.
&lt;/p&gt;

&lt;p&gt;
BTW, I can edit the patch on the spot when applying hunks. Similar to the work flow of &lt;code&gt;git add --patch&lt;/code&gt;.
&lt;/p&gt;

&lt;p&gt;
The solution is added into &lt;a href="https://github.com/technomancy/find-file-in-project"&gt;https://github.com/technomancy/find-file-in-project&lt;/a&gt;.&lt;/p&gt;&lt;/div&gt;</description><category>diff</category><category>emacs</category><category>en</category><category>ivy</category><guid>http://blog.binchen.org/posts/enhance-diff-mode-with-ivy.html</guid><pubDate>Tue, 30 May 2017 12:29:12 GMT</pubDate></item></channel></rss>