<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/"><channel><title>Chen's blog (evil)</title><link>http://blog.binchen.org/</link><description></description><atom:link href="http://blog.binchen.org/categories/evil.xml" type="application/rss+xml" rel="self"></atom:link><language>en</language><lastBuildDate>Thu, 12 Nov 2015 06:02:58 GMT</lastBuildDate><generator>https://getnikola.com/</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Evil text object to select nearby file path</title><link>http://blog.binchen.org/posts/evil-text-object-to-select-nearby-file-path.html</link><dc:creator>Chen Bin</dc:creator><description>&lt;div&gt;&lt;p&gt;CREATED: &lt;span class="timestamp-wrapper"&gt; &lt;span class="timestamp"&gt;2015-08-08 Sat&lt;/span&gt;&lt;/span&gt;
&lt;/p&gt;

&lt;p&gt;
UPDATED: &lt;span class="timestamp-wrapper"&gt; &lt;span class="timestamp"&gt;2015-08-24 Mon&lt;/span&gt;&lt;/span&gt;
&lt;/p&gt;

&lt;p&gt;
Insert below code into ~/.emacs:
&lt;/p&gt;

&lt;pre&gt;&lt;code class="lang-lisp"&gt;;; {{ nearby file path as text object,
;;      - "vif" to select only basename
;;      - "vaf" to select the full path
;;
;;  example: "/hello/world" "/test/back.exe"
;;               "C:hello\\hello\\world\\test.exe" "D:blah\\hello\\world\\base.exe"
;;
;; tweak evil-filepath-is-nonname to re-define a path
(defun evil-filepath-is-separator-char (ch)
  "Check ascii table"
  (let (rlt)
    (if (or (= ch 47)
            (= ch 92))
        (setq rlt t))
    rlt))

(defun evil-filepath-not-path-char (ch)
  "Check ascii table for charctater "
  (let (rlt)
    (if (or (and (&amp;lt;= 0 ch) (&amp;lt;= ch 32))
            (= ch 34) ; double quotes
            (= ch 39) ; single quote
            (= ch 40) ; (
            (= ch 41) ; )
            (= ch 60) ; &amp;lt;
            (= ch 62) ; &amp;gt;
            (= ch 91) ; [
            (= ch 93) ; ]
            (= ch 96) ; `
            (= ch 123) ; {
            (= ch 125) ; }
            (= 127 ch))
        (setq rlt t))
    rlt))

(defun evil-filepath-char-not-placed-at-end-of-path (ch)
  (or (= 44 ch) ; ,
      (= 46 ch) ; .
      ))

(defun evil-filepath-calculate-path (b e)
  (let (rlt f)
    (when (and b e)
      (setq b (+ 1 b))
      (when (save-excursion
                (goto-char e)
                (setq f (evil-filepath-search-forward-char 'evil-filepath-is-separator-char t))
                (and f (&amp;gt;= f b)))
        (setq rlt (list b (+ 1 f) (- e 1)))))
    rlt))

(defun evil-filepath-get-path-already-inside ()
  (let (b e)
    (save-excursion
      (setq b (evil-filepath-search-forward-char 'evil-filepath-not-path-char t)))
    (save-excursion
      (setq e (evil-filepath-search-forward-char 'evil-filepath-not-path-char))
      (when e
        (goto-char (- e 1))
        ;; example: hello/world,
        (if (evil-filepath-char-not-placed-at-end-of-path (following-char))
            (setq e (- e 1)))
        ))
    (evil-filepath-calculate-path b e)))

(defun evil-filepath-search-forward-char (fn &amp;amp;optional backward)
  (let (found rlt (limit (if backward (point-min) (point-max))) out)
    (save-excursion
      (while (not out)
        ;; for the char, exit
        (if (setq found (apply fn (list (following-char))))
            (setq out t)
          ;; reach the limit, exit
          (if (= (point) limit)
              (setq out t)
            ;; keep moving
            (if backward (backward-char) (forward-char)))))
      (if found (setq rlt (point))))
    rlt))

(defun evil-filepath-extract-region ()
  "Find the closest file path"
  (let (rlt b f1 f2)

    (if (and (not (evil-filepath-not-path-char (following-char)))
             (setq rlt (evil-filepath-get-path-already-inside)))
        ;; maybe (point) is in the middle of the path
        t
      ;; need search forward AND backward to find the right path
      (save-excursion
        ;; path in backward direction
        (when (setq b (evil-filepath-search-forward-char 'evil-filepath-is-separator-char t))
          (goto-char b)
          (setq f1 (evil-filepath-get-path-already-inside))))
      (save-excursion
        ;; path in forward direction
        (when (setq b (evil-filepath-search-forward-char 'evil-filepath-is-separator-char))
          (goto-char b)
          (setq f2 (evil-filepath-get-path-already-inside))))
      ;; pick one path as the final result
      (cond
       ((and f1 f2)
        (if (&amp;gt; (- (point) (nth 2 f1)) (- (nth 0 f2) (point)))
            (setq rlt f2)
          (setq rlt f1)))
       (f1
        (setq rlt f1))
       (f2
        (setq rlt f2))))

    rlt))

(evil-define-text-object evil-filepath-inner-text-object (&amp;amp;optional count begin end type)
  "File name of nearby path"
  (let ((selected-region (evil-filepath-extract-region)))
    (if selected-region
        (evil-range (nth 1 selected-region) (nth 2 selected-region) :expanded t))))

(evil-define-text-object evil-filepath-outer-text-object (&amp;amp;optional NUM begin end type)
  "Nearby path"
  (let ((selected-region (evil-filepath-extract-region)))
    (if selected-region
        (evil-range (car selected-region) (+ 1 (nth 2 selected-region)) type :expanded t))))

(define-key evil-inner-text-objects-map "f" 'evil-filepath-inner-text-object)
(define-key evil-outer-text-objects-map "f" 'evil-filepath-outer-text-object)
;; }}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description><category>emacs</category><category>en</category><category>evil</category><guid>http://blog.binchen.org/posts/evil-text-object-to-select-nearby-file-path.html</guid><pubDate>Sat, 08 Aug 2015 13:16:39 GMT</pubDate></item><item><title>How to avoid Repeated Strain Injury when using emacs by re-assigning hotkeys</title><link>http://blog.binchen.org/posts/how-to-avoid-ris-when-using-emacs-by-re-assigning-hotkeys-2.html</link><dc:creator>Chen Bin</dc:creator><description>&lt;div&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt; I've read all the Emacs RSI related articles from the internet. &lt;/p&gt;  &lt;p&gt; Typical solutions are: &lt;/p&gt; &lt;ul class="org-ul"&gt;&lt;li&gt;buy special hardwares &lt;/li&gt; &lt;li&gt;remap ctrl key (because Emacs users press Ctrl key too often) &lt;/li&gt; &lt;li&gt;use Vi key binding &lt;/li&gt; &lt;li&gt;other Emacs keybinding with some hacking &lt;/li&gt; &lt;li&gt;voice input &lt;/li&gt; &lt;/ul&gt;&lt;p&gt; I will disscuss the third item "use Vim key binding" because there is still room to improve. &lt;/p&gt;  &lt;p&gt; Here is my observation. Even I use Vi keybinding, there are top three frequently pressed keys which may hurt my left hand: "ESC", "C-x", "C-g" &lt;/p&gt;  &lt;p&gt; These top three need me move my left hands too often. That may be the problem of RSI. In this case, A little knowledge of Vim will help. &lt;/p&gt;  &lt;p&gt; In vi, we use key combination start with &amp;lt;leader&amp;gt; key. The leader key is actually the comma key ",". &lt;/p&gt;  &lt;p&gt; As you can see, comma key is close to the right hand fingers. So using key combination with leader key as the first key to press will give more spare hot keys to replace "ESC", "C-x" and "C-g". &lt;/p&gt;  &lt;p&gt; The princple here is &lt;b&gt;DO NOT&lt;/b&gt; move hands at all. Following this example, I can figure out many practical solution. &lt;/p&gt;  &lt;p&gt; For example, by using &lt;a href="http://www.emacswiki.org/emacs/Evil"&gt;evil&lt;/a&gt; and &lt;a href="https://github.com/cofi/evil-leader"&gt;evil-leader&lt;/a&gt;. With hot key prefix "C-x", I use ",x" to replace. For example, "C-x C-c" is replaced with ",xc", &lt;/p&gt; &lt;div class="org-src-container"&gt;&lt;br&gt;&lt;pre class="prettyprint "&gt;
&lt;p&gt;(require 'evil-leader)&lt;/p&gt;
&lt;p&gt;(evil-leader/set-key
  "xf" 'ido-find-file
  "xb" 'ido-switch-buffer
  "xc" 'save-buffers-kill-terminal
  "jj" 'w3mext-search-js-api-mdn
  "xz" 'suspend-frame
  "xvv" 'vc-next-action
  "xv=" 'vc-diff
  "xvl" 'vc-print-log
  )&lt;/p&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;/p&gt;&lt;/div&gt;  &lt;p&gt; On some keyboard, the "Alt" key is easy to press because it's big and just under the big thumb. So I can assign some key combination like "M-k" to replace "C-g". &lt;/p&gt;  &lt;p&gt; Please note "Alt" and "k" is also close to my fingers. Here is my setup in .emacs: &lt;/p&gt; &lt;div class="org-src-container"&gt;&lt;br&gt;&lt;pre class="prettyprint "&gt;
&lt;p&gt;(global-set-key (kbd "M-k") 'keyboard-quit)&lt;/p&gt;
&lt;p&gt;(define-key evil-insert-state-map (kbd "M-k") 'evil-normal-state)&lt;/p&gt;
&lt;p&gt;(define-key evil-visual-state-map (kbd ",k") 'evil-exit-visual-state)&lt;/p&gt;
&lt;p&gt;(define-key minibuffer-local-map (kbd ",k") 'abort-recursive-edit)&lt;/p&gt;
&lt;p&gt;(define-key evil-insert-state-map (kbd "M-j") 'yas-expand)&lt;/p&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;/p&gt;&lt;/div&gt;  &lt;p&gt; Some minor modes will re-assign the hot key "C-g", so when I say replace "C-g" with ",k". It may be a bit more elisp code: &lt;/p&gt; &lt;div class="org-src-container"&gt;&lt;br&gt;&lt;pre class="prettyprint "&gt;
&lt;p&gt;;; the original hot key of helm-keyboard-quit is "C-g"&lt;/p&gt;
&lt;p&gt;(define-key helm-map (kbd ",k") 'helm-keyboard-quit)&lt;/p&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;/p&gt;&lt;/div&gt;  &lt;p&gt; The key point is to understand the princiles instead copy my configuration: &lt;/p&gt; &lt;ul class="org-ul"&gt;&lt;li&gt;comma is a good key for hot key prefix, it's used by vi users for ages &lt;/li&gt; &lt;li&gt;use keys close to fingers (L,J,K,L, for example) in hot keys  &lt;/li&gt; &lt;li&gt;Other keys close to right hand is also useful in key combinations &lt;/li&gt; &lt;li&gt;Avoid move left hand &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;</description><category>emacs</category><category>en</category><category>evil</category><category>rsi</category><guid>http://blog.binchen.org/posts/how-to-avoid-ris-when-using-emacs-by-re-assigning-hotkeys-2.html</guid><pubDate>Fri, 09 Aug 2013 08:05:00 GMT</pubDate></item><item><title>How to refactor/rename a variable name in a function efficiently</title><link>http://blog.binchen.org/posts/how-to-refactorrename-a-variable-name-in-a-function-efficiently.html</link><dc:creator>Chen Bin</dc:creator><description>&lt;div&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;As we dicussed in &lt;a href="https://plus.google.com/110954683162859211810/posts/TgnyDRqBWkb"&gt;Emacs community at Google+&lt;/a&gt;. Although &lt;a href="https://github.com/magnars/multiple-cursors.el"&gt;multiple-cursor&lt;/a&gt; is good for this task, I cannot use it because it conflicts with my favourite &lt;a href="http://www.emacswiki.org/emacs/Evil"&gt;evil-mode&lt;/a&gt; (Vim simulation in Emacs). &lt;/p&gt; &lt;p&gt; There is another emacs plugin called &lt;a href="https://github.com/victorhge/iedit"&gt;iedit&lt;/a&gt; which could do the similar job (I usually use its command called iedit-mode-toggle-on-function) &lt;/p&gt; &lt;p&gt; Though iedit is good, there is still room for improvement. When using iedit-mode-toggle-on-function, we need press key twice to rename the variable name. Once to enable it, twice to disable it. &lt;/p&gt; &lt;p&gt; Magnar Sveen pointed out in the G+ discussion that the key point we need plugins like multiple-cursor or iedit-mode is that we can see all the changes while doing the editing. &lt;/p&gt; &lt;p&gt; This reminds me that evil-mode has a excellent regex string replacing mode which also show the changes when you are typing EACH character of new string. &lt;/p&gt; &lt;p&gt; So by using evil-mode's default regex replacing command, I can implement similar feature even more efficiently then iedit-mode! &lt;/p&gt; &lt;p&gt; Here is my elisp code: &lt;/p&gt;   &lt;pre class="src src-elisp"&gt;(&lt;span style="color: #b9ca4a;"&gt;defun&lt;/span&gt; &lt;span style="color: #7aa6da;"&gt;evilcvn-change-symbol-in-defun&lt;/span&gt; ()
  &lt;span style="color: #c397d8;"&gt;"mark the region in defun (definition of function) and use string replacing UI in evil-mode&lt;/span&gt;
&lt;span style="color: #c397d8;"&gt;to replace the symbol under cursor"&lt;/span&gt;
  (interactive)
  (&lt;span style="color: #b9ca4a;"&gt;let&lt;/span&gt; ((old (thing-at-point 'symbol)))
    (mark-defun)
    (&lt;span style="color: #b9ca4a;"&gt;unless&lt;/span&gt; (evil-visual-state-p)
      (evil-visual-state))
    (evil-ex (concat &lt;span style="color: #70c0b1;"&gt;"'&amp;lt;,'&amp;gt;s/"&lt;/span&gt; (&lt;span style="color: #b9ca4a;"&gt;if&lt;/span&gt; (= 0 (length old)) &lt;span style="color: #70c0b1;"&gt;""&lt;/span&gt; &lt;span style="color: #70c0b1;"&gt;"\&amp;lt;&lt;/span&gt;&lt;span style="color: #e7c547; font-weight: bold;"&gt;\&lt;/span&gt;&lt;span style="color: #c397d8; font-weight: bold;"&gt;(&lt;/span&gt;&lt;span style="color: #70c0b1;"&gt;"&lt;/span&gt;) old (&lt;span style="color: #b9ca4a;"&gt;if&lt;/span&gt; (= 0 (length old)) &lt;span style="color: #70c0b1;"&gt;""&lt;/span&gt; &lt;span style="color: #70c0b1;"&gt;"&lt;/span&gt;&lt;span style="color: #e7c547; font-weight: bold;"&gt;\&lt;/span&gt;&lt;span style="color: #c397d8; font-weight: bold;"&gt;)&lt;/span&gt;&lt;span style="color: #70c0b1;"&gt;\&amp;gt;/"&lt;/span&gt;))))
  )
(global-set-key (kbd &lt;span style="color: #70c0b1;"&gt;"C-c ; s"&lt;/span&gt;) 'evilcvn-change-symbol-in-defun)
&lt;p&gt;&lt;/p&gt;&lt;/pre&gt;   &lt;p&gt; Put you cursor above a symbol/variable and press hot key "Ctrl-c ; s", then the regex to replace that symbol is automatically created and inserted into mini-buffer. Now you only need type new string and watch. &lt;/p&gt; &lt;p&gt; This is the screen shot (I renamed variable "count" into "cnt" in C++ function hello): &lt;img src="http://blog.binchen.org/wp-content/uploads/2013/05/wpid-evil-regex-replace-nq8.png" alt="image/evil-regex-replace-nq8.png"&gt;&lt;/p&gt;&lt;/div&gt;</description><category>emacs</category><category>en</category><category>evil</category><category>programming</category><guid>http://blog.binchen.org/posts/how-to-refactorrename-a-variable-name-in-a-function-efficiently.html</guid><pubDate>Thu, 23 May 2013 21:05:00 GMT</pubDate></item></channel></rss>